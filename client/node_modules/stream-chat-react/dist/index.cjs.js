'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Window = require('./Window-194c5448.js');
var React = require('react');
var streamChat = require('stream-chat');
var reactVirtuoso = require('react-virtuoso');
var throttle = require('lodash.throttle');
require('emoji-regex');
require('linkifyjs');
require('lodash.uniqby');
require('@braintree/sanitize-url');
require('react-image-gallery');
require('react-dom');
require('react-fast-compare');
require('lodash.debounce');
require('dayjs');
require('dayjs/plugin/calendar');
require('dayjs/plugin/localizedFormat');
require('i18next');
require('dayjs/plugin/updateLocale');
require('dayjs/plugin/localeData');
require('dayjs/plugin/relativeTime');
require('dayjs/plugin/utc');
require('dayjs/plugin/timezone');
require('dayjs/locale/de');
require('dayjs/locale/es');
require('dayjs/locale/fr');
require('dayjs/locale/hi');
require('dayjs/locale/it');
require('dayjs/locale/ja');
require('dayjs/locale/ko');
require('dayjs/locale/nl');
require('dayjs/locale/pt');
require('dayjs/locale/ru');
require('dayjs/locale/tr');
require('dayjs/locale/en');
require('react-player');
require('pretty-bytes');
require('prop-types');
require('@babel/runtime/helpers/extends');
require('@babel/runtime/helpers/defineProperty');
require('react-textarea-autosize');
require('textarea-caret');
require('react-is');
require('crypto');
require('react/jsx-runtime');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var throttle__default = /*#__PURE__*/_interopDefaultLegacy(throttle);

/**
 * @deprecated This component has beend deprecated in favor of [`MessageInputFlat`](./MessageInputFlat.tsx) from which
 * `MessageInputSmall` "inherited" most of the code with only slight modification to classNames
 * and markup.
 * In case you need to change styling in places where `MessageInputSmall` has been used previously ([`Thread`](../Thread/Thread.tsx))
 * please do so by updating the CSS or by overriding the component itself.
 *
 * **Will be removed with the complete transition to the theming V2 (next major release - `v11.0.0`).**
 */
var MessageInputSmall = function () {
    var _a = Window.useChannelStateContext('MessageInputSmall'), acceptedFiles = _a.acceptedFiles, multipleUploads = _a.multipleUploads, quotedMessage = _a.quotedMessage;
    var setQuotedMessage = Window.useChannelActionContext('MessageInputSmall').setQuotedMessage;
    var t = Window.useTranslationContext('MessageInputSmall').t;
    var channel = Window.useChatContext('MessageInputSmall').channel;
    var _b = Window.useMessageInputContext('MessageInputSmall'), cooldownRemaining = _b.cooldownRemaining, handleSubmit = _b.handleSubmit, hideSendButton = _b.hideSendButton, isUploadEnabled = _b.isUploadEnabled, maxFilesLeft = _b.maxFilesLeft, numberOfUploads = _b.numberOfUploads, setCooldownRemaining = _b.setCooldownRemaining, uploadNewFiles = _b.uploadNewFiles;
    var _c = Window.useComponentContext('MessageInputSmall'), _d = _c.CooldownTimer, CooldownTimer = _d === void 0 ? Window.CooldownTimer : _d, _e = _c.FileUploadIcon, FileUploadIcon = _e === void 0 ? Window.FileUploadIconFlat : _e, _f = _c.SendButton, SendButton = _f === void 0 ? Window.SendButton : _f, _g = _c.QuotedMessagePreview, QuotedMessagePreview = _g === void 0 ? Window.QuotedMessagePreview : _g, EmojiPicker = _c.EmojiPicker;
    React.useEffect(function () {
        var handleQuotedMessageUpdate = function (e) {
            var _a;
            if (!(quotedMessage && ((_a = e.message) === null || _a === void 0 ? void 0 : _a.id) === quotedMessage.id))
                return;
            if (e.type === 'message.deleted') {
                setQuotedMessage(undefined);
                return;
            }
            setQuotedMessage(e.message);
        };
        channel === null || channel === void 0 ? void 0 : channel.on('message.deleted', handleQuotedMessageUpdate);
        channel === null || channel === void 0 ? void 0 : channel.on('message.updated', handleQuotedMessageUpdate);
        return function () {
            channel === null || channel === void 0 ? void 0 : channel.off('message.deleted', handleQuotedMessageUpdate);
            channel === null || channel === void 0 ? void 0 : channel.off('message.updated', handleQuotedMessageUpdate);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [channel, quotedMessage]);
    return (React__default["default"].createElement("div", { className: 'str-chat__small-message-input__wrapper' },
        React__default["default"].createElement(Window.ImageDropzone, { accept: acceptedFiles, disabled: !isUploadEnabled || maxFilesLeft === 0 || !!cooldownRemaining, handleFiles: uploadNewFiles, maxNumberOfFiles: maxFilesLeft, multiple: multipleUploads },
            React__default["default"].createElement("div", { className: "str-chat__small-message-input ".concat(SendButton ? 'str-chat__small-message-input--send-button-active' : '', " ").concat(quotedMessage && quotedMessage.parent_id ? 'str-chat__input-flat-quoted' : '', " ").concat(numberOfUploads ? 'str-chat__small-message-input-has-attachments' : '', " ") },
                quotedMessage && quotedMessage.parent_id && (React__default["default"].createElement(QuotedMessagePreview, { quotedMessage: quotedMessage })),
                isUploadEnabled && React__default["default"].createElement(Window.UploadsPreview, null),
                React__default["default"].createElement("div", { className: 'str-chat__small-message-input--textarea-wrapper' },
                    React__default["default"].createElement(Window.ChatAutoComplete, null),
                    cooldownRemaining ? (React__default["default"].createElement("div", { className: 'str-chat__input-small-cooldown' },
                        React__default["default"].createElement(CooldownTimer, { cooldownInterval: cooldownRemaining, setCooldownRemaining: setCooldownRemaining }))) : (React__default["default"].createElement(React__default["default"].Fragment, null,
                        isUploadEnabled && (React__default["default"].createElement("div", { className: 'str-chat__fileupload-wrapper', "data-testid": 'fileinput' },
                            React__default["default"].createElement(Window.Tooltip, null, maxFilesLeft
                                ? t('Attach files')
                                : t("You've reached the maximum number of files")),
                            React__default["default"].createElement(Window.FileUploadButton, { accepts: acceptedFiles, disabled: maxFilesLeft === 0, handleFiles: uploadNewFiles, multiple: multipleUploads },
                                React__default["default"].createElement("span", { className: 'str-chat__small-message-input-fileupload' },
                                    React__default["default"].createElement(FileUploadIcon, null))))),
                        EmojiPicker && (React__default["default"].createElement(EmojiPicker
                        // @ts-expect-error
                        , { 
                            // @ts-expect-error
                            buttonClassName: 'str-chat__small-message-input-emojiselect', ButtonIconComponent: Window.EmojiIconSmall }))))),
                !(cooldownRemaining || hideSendButton) && React__default["default"].createElement(SendButton, { sendMessage: handleSubmit })))));
};

var GiphyPreviewMessage = function (props) {
    var message = props.message;
    return (React__default["default"].createElement("div", { className: 'giphy-preview-message' },
        React__default["default"].createElement(Window.Message, { message: message })));
};

var useEnrichedMessages = function (args) {
    var channel = args.channel, disableDateSeparator = args.disableDateSeparator, groupStyles = args.groupStyles, headerPosition = args.headerPosition, hideDeletedMessages = args.hideDeletedMessages, hideNewMessageSeparator = args.hideNewMessageSeparator, messages = args.messages, noGroupByUser = args.noGroupByUser;
    var client = Window.useChatContext('useEnrichedMessages').client;
    var HeaderComponent = Window.useComponentContext('useEnrichedMessages').HeaderComponent;
    var lastRead = React.useMemo(function () { var _a; return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel); }, [channel]);
    var enableDateSeparator = !disableDateSeparator;
    var messagesWithDates = !enableDateSeparator && !hideDeletedMessages && hideNewMessageSeparator
        ? messages
        : Window.processMessages({
            enableDateSeparator: enableDateSeparator,
            hideDeletedMessages: hideDeletedMessages,
            hideNewMessageSeparator: hideNewMessageSeparator,
            lastRead: lastRead,
            messages: messages,
            userId: client.userID || '',
        });
    if (HeaderComponent) {
        messagesWithDates = Window.insertIntro(messagesWithDates, headerPosition);
    }
    var groupStylesFn = groupStyles || Window.getGroupStyles;
    var messageGroupStyles = React.useMemo(function () {
        return messagesWithDates.reduce(function (acc, message, i) {
            var style = groupStylesFn(message, messagesWithDates[i - 1], messagesWithDates[i + 1], noGroupByUser);
            if (style)
                acc[message.id] = style;
            return acc;
        }, {});
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [messagesWithDates, noGroupByUser]);
    return { messageGroupStyles: messageGroupStyles, messages: messagesWithDates };
};

var useLastReadData = function (props) {
    var messages = props.messages, read = props.read, returnAllReadData = props.returnAllReadData, userID = props.userID;
    return React.useMemo(function () {
        return Window.getReadStates(messages.filter(function (_a) {
            var user = _a.user;
            return (user === null || user === void 0 ? void 0 : user.id) === userID;
        }), read, returnAllReadData);
    }, [messages, read, returnAllReadData, userID]);
};

var useMessageListElements = function (props) {
    var channelUnreadUiState = props.channelUnreadUiState, enrichedMessages = props.enrichedMessages, internalMessageProps = props.internalMessageProps, messageGroupStyles = props.messageGroupStyles, read = props.read, renderMessages = props.renderMessages, returnAllReadData = props.returnAllReadData, threadList = props.threadList;
    var _a = Window.useChatContext('useMessageListElements'), client = _a.client, customClasses = _a.customClasses;
    var components = Window.useComponentContext('useMessageListElements');
    // get the readData, but only for messages submitted by the user themselves
    var readData = useLastReadData({
        messages: enrichedMessages,
        read: read,
        returnAllReadData: returnAllReadData,
        userID: client.userID,
    });
    var lastReceivedMessageId = React.useMemo(function () { return Window.getLastReceived(enrichedMessages); }, [
        enrichedMessages,
    ]);
    var elements = React.useMemo(function () {
        return renderMessages({
            channelUnreadUiState: channelUnreadUiState,
            components: components,
            customClasses: customClasses,
            lastReceivedMessageId: lastReceivedMessageId,
            messageGroupStyles: messageGroupStyles,
            messages: enrichedMessages,
            readData: readData,
            sharedMessageProps: Window.__assign(Window.__assign({}, internalMessageProps), { threadList: threadList }),
        });
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        enrichedMessages,
        internalMessageProps,
        lastReceivedMessageId,
        messageGroupStyles,
        channelUnreadUiState,
        readData,
        renderMessages,
        threadList,
    ]);
    return elements;
};

// FIXME: change this generic name to something like useAdjustScrollPositionToListSize
function useMessageListScrollManager(params) {
    var loadMoreScrollThreshold = params.loadMoreScrollThreshold, onScrollBy = params.onScrollBy, scrollContainerMeasures = params.scrollContainerMeasures, scrolledUpThreshold = params.scrolledUpThreshold, scrollToBottom = params.scrollToBottom, showNewMessages = params.showNewMessages;
    var client = Window.useChatContext('useMessageListScrollManager').client;
    var measures = React.useRef({
        offsetHeight: 0,
        scrollHeight: 0,
    });
    var messages = React.useRef();
    var scrollTop = React.useRef(0);
    React.useLayoutEffect(function () {
        var _a, _b, _c;
        var prevMeasures = measures.current;
        var prevMessages = messages.current;
        var newMessages = params.messages;
        var lastNewMessage = newMessages[newMessages.length - 1] || {};
        var lastPrevMessage = prevMessages === null || prevMessages === void 0 ? void 0 : prevMessages[prevMessages.length - 1];
        var newMeasures = scrollContainerMeasures();
        var wasAtBottom = prevMeasures.scrollHeight - prevMeasures.offsetHeight - scrollTop.current <
            scrolledUpThreshold;
        if (typeof prevMessages !== 'undefined') {
            if (prevMessages.length < newMessages.length) {
                // messages added to the top
                if ((lastPrevMessage === null || lastPrevMessage === void 0 ? void 0 : lastPrevMessage.id) === lastNewMessage.id) {
                    if (scrollTop.current < loadMoreScrollThreshold) {
                        var listHeightDelta = newMeasures.scrollHeight - prevMeasures.scrollHeight;
                        onScrollBy(listHeightDelta);
                    }
                }
                // messages added to the bottom
                else {
                    var lastMessageIsFromCurrentUser = ((_a = lastNewMessage.user) === null || _a === void 0 ? void 0 : _a.id) === client.userID;
                    if (lastMessageIsFromCurrentUser || wasAtBottom) {
                        scrollToBottom();
                    }
                    else {
                        showNewMessages();
                    }
                }
            }
            // message list length didn't change, but check if last message had reaction/reply update
            else {
                var hasNewReactions = ((_b = lastPrevMessage === null || lastPrevMessage === void 0 ? void 0 : lastPrevMessage.latest_reactions) === null || _b === void 0 ? void 0 : _b.length) !== ((_c = lastNewMessage.latest_reactions) === null || _c === void 0 ? void 0 : _c.length);
                var hasNewReplies = (lastPrevMessage === null || lastPrevMessage === void 0 ? void 0 : lastPrevMessage.reply_count) !== lastNewMessage.reply_count;
                if ((hasNewReactions || hasNewReplies) && wasAtBottom) {
                    scrollToBottom();
                }
            }
        }
        messages.current = newMessages;
        measures.current = newMeasures;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [measures, messages, params.messages]);
    return function (scrollTopValue) {
        scrollTop.current = scrollTopValue;
    };
}

var useScrollLocationLogic = function (params) {
    var loadMoreScrollThreshold = params.loadMoreScrollThreshold, _a = params.messages, messages = _a === void 0 ? [] : _a, _b = params.scrolledUpThreshold, scrolledUpThreshold = _b === void 0 ? 200 : _b, hasMoreNewer = params.hasMoreNewer, suppressAutoscroll = params.suppressAutoscroll, listElement = params.listElement;
    var _c = React.useState(false), hasNewMessages = _c[0], setHasNewMessages = _c[1];
    var _d = React.useState(), wrapperRect = _d[0], setWrapperRect = _d[1];
    var _e = React.useState(true), isMessageListScrolledToBottom = _e[0], setIsMessageListScrolledToBottom = _e[1];
    var closeToBottom = React.useRef(false);
    var closeToTop = React.useRef(false);
    var scrollToBottom = React.useCallback(function () {
        if (!(listElement === null || listElement === void 0 ? void 0 : listElement.scrollTo) || hasMoreNewer || suppressAutoscroll) {
            return;
        }
        listElement.scrollTo({
            top: listElement.scrollHeight,
        });
        setHasNewMessages(false);
    }, [listElement, hasMoreNewer, suppressAutoscroll]);
    React.useLayoutEffect(function () {
        if (listElement) {
            setWrapperRect(listElement.getBoundingClientRect());
            scrollToBottom();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [listElement, hasMoreNewer]);
    var updateScrollTop = useMessageListScrollManager({
        loadMoreScrollThreshold: loadMoreScrollThreshold,
        messages: messages,
        onScrollBy: function (scrollBy) {
            listElement === null || listElement === void 0 ? void 0 : listElement.scrollBy({ top: scrollBy });
        },
        scrollContainerMeasures: function () { return ({
            offsetHeight: (listElement === null || listElement === void 0 ? void 0 : listElement.offsetHeight) || 0,
            scrollHeight: (listElement === null || listElement === void 0 ? void 0 : listElement.scrollHeight) || 0,
        }); },
        scrolledUpThreshold: scrolledUpThreshold,
        scrollToBottom: scrollToBottom,
        showNewMessages: function () { return setHasNewMessages(true); },
    });
    var onScroll = React.useCallback(function (event) {
        var element = event.target;
        var scrollTop = element.scrollTop;
        updateScrollTop(scrollTop);
        var offsetHeight = element.offsetHeight;
        var scrollHeight = element.scrollHeight;
        var prevCloseToBottom = closeToBottom.current;
        closeToBottom.current = scrollHeight - (scrollTop + offsetHeight) < scrolledUpThreshold;
        closeToTop.current = scrollTop < scrolledUpThreshold;
        if (closeToBottom.current) {
            setHasNewMessages(false);
        }
        if (prevCloseToBottom && !closeToBottom.current) {
            setIsMessageListScrolledToBottom(false);
        }
        else if (!prevCloseToBottom && closeToBottom.current) {
            setIsMessageListScrolledToBottom(true);
        }
    }, [updateScrollTop, closeToTop, closeToBottom, scrolledUpThreshold]);
    return {
        hasNewMessages: hasNewMessages,
        isMessageListScrolledToBottom: isMessageListScrolledToBottom,
        onScroll: onScroll,
        scrollToBottom: scrollToBottom,
        wrapperRect: wrapperRect,
    };
};

var MESSAGE_LIST_MAIN_PANEL_CLASS = 'str-chat__main-panel-inner';
var MessageListMainPanel = function (_a) {
    var children = _a.children;
    var themeVersion = Window.useChatContext('MessageListMainPanel').themeVersion;
    if (themeVersion === '2')
        return React__default["default"].createElement("div", { className: MESSAGE_LIST_MAIN_PANEL_CLASS }, children);
    return React__default["default"].createElement(React__default["default"].Fragment, null, children);
};

var targetScrolledAboveVisibleContainerArea = function (element) {
    var targetBottom = element.getBoundingClientRect().bottom;
    return targetBottom < 0;
};
var targetScrolledBelowVisibleContainerArea = function (element, container) {
    var targetTop = element.getBoundingClientRect().top;
    var containerBottom = container.getBoundingClientRect().top;
    return targetTop > containerBottom;
};
var useUnreadMessagesNotification = function (_a) {
    var isMessageListScrolledToBottom = _a.isMessageListScrolledToBottom, showAlways = _a.showAlways, unreadCount = _a.unreadCount;
    var messages = Window.useChannelStateContext('UnreadMessagesNotification').messages;
    var _b = React.useState(false), show = _b[0], setShow = _b[1];
    var isScrolledAboveTargetTop = React.useRef(false);
    var intersectionObserverIsSupported = typeof IntersectionObserver !== 'undefined';
    React.useEffect(function () {
        if (!(unreadCount && intersectionObserverIsSupported)) {
            setShow(false);
            return;
        }
        var msgListPanel = document.querySelector(".".concat(MESSAGE_LIST_MAIN_PANEL_CLASS));
        if (!msgListPanel)
            return;
        var observedTarget = document.querySelector(".".concat(Window.UNREAD_MESSAGE_SEPARATOR_CLASS));
        if (!observedTarget) {
            setShow(true);
            return;
        }
        var scrolledBelowSeparator = targetScrolledAboveVisibleContainerArea(observedTarget);
        var scrolledAboveSeparator = targetScrolledBelowVisibleContainerArea(observedTarget, msgListPanel);
        setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);
        var observer = new IntersectionObserver(function (elements) {
            if (!elements.length)
                return;
            var _a = elements[0], boundingClientRect = _a.boundingClientRect, isIntersecting = _a.isIntersecting;
            if (isIntersecting) {
                setShow(false);
                return;
            }
            var separatorIsAboveContainerTop = boundingClientRect.bottom < 0;
            setShow(showAlways || separatorIsAboveContainerTop);
            isScrolledAboveTargetTop.current = separatorIsAboveContainerTop;
        }, { root: msgListPanel });
        observer.observe(observedTarget);
        return function () {
            observer.disconnect();
        };
    }, [
        intersectionObserverIsSupported,
        isMessageListScrolledToBottom,
        messages,
        showAlways,
        unreadCount,
    ]);
    React.useEffect(function () {
        /**
         * Handle situation when scrollToBottom is called from another component when the msg list is scrolled above the observed target (unread separator).
         * The intersection observer is not triggered when Element.scrollTo() is called. So we end up in a situation when we are scrolled to the bottom
         * and at the same time scrolled above the observed target.
         */
        if (unreadCount && isMessageListScrolledToBottom && isScrolledAboveTargetTop.current) {
            setShow(true);
            isScrolledAboveTargetTop.current = false;
        }
    }, [isMessageListScrolledToBottom, unreadCount]);
    return { show: show && intersectionObserverIsSupported };
};

/**
 * Takes care of marking a channel read. The channel is read only if all the following applies:
 * 1. the message list is not rendered in a thread
 * 2. the message list is scrolled to the bottom
 * 3. the channel was not marked unread by the user
 * @param isMessageListScrolledToBottom
 * @param messageListIsThread
 * @param unreadCount
 * @param wasChannelMarkedUnread
 */
var useMarkRead = function (_a) {
    var isMessageListScrolledToBottom = _a.isMessageListScrolledToBottom, messageListIsThread = _a.messageListIsThread, unreadCount = _a.unreadCount, wasMarkedUnread = _a.wasMarkedUnread;
    var client = Window.useChatContext('useMarkRead').client;
    var _b = Window.useChannelActionContext('useMarkRead'), markRead = _b.markRead, setChannelUnreadUiState = _b.setChannelUnreadUiState;
    var channel = Window.useChannelStateContext('useMarkRead').channel;
    var previousRenderMessageListScrolledToBottom = React.useRef(isMessageListScrolledToBottom);
    React.useEffect(function () {
        var shouldMarkRead = function (unreadMessages) {
            return !document.hidden &&
                !wasMarkedUnread &&
                !messageListIsThread &&
                isMessageListScrolledToBottom &&
                unreadMessages > 0;
        };
        var onVisibilityChange = function () {
            if (shouldMarkRead(unreadCount))
                markRead();
        };
        var handleMessageNew = function (event) {
            var _a, _b, _c, _d;
            var newMessageToCurrentChannel = event.cid === channel.cid;
            var isOwnMessage = ((_a = event.user) === null || _a === void 0 ? void 0 : _a.id) && event.user.id === ((_b = client.user) === null || _b === void 0 ? void 0 : _b.id);
            var mainChannelUpdated = !((_c = event.message) === null || _c === void 0 ? void 0 : _c.parent_id) || ((_d = event.message) === null || _d === void 0 ? void 0 : _d.show_in_channel);
            if (isOwnMessage)
                return;
            if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {
                setChannelUnreadUiState(function (prev) {
                    var _a, _b;
                    var previousUnreadCount = (_a = prev === null || prev === void 0 ? void 0 : prev.unread_messages) !== null && _a !== void 0 ? _a : 0;
                    var previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);
                    return Window.__assign(Window.__assign({}, (prev || {})), { last_read: (_b = prev === null || prev === void 0 ? void 0 : prev.last_read) !== null && _b !== void 0 ? _b : (previousUnreadCount === 0 && (previousLastMessage === null || previousLastMessage === void 0 ? void 0 : previousLastMessage.created_at)
                            ? new Date(previousLastMessage.created_at)
                            : new Date(0)), unread_messages: previousUnreadCount + 1 });
                });
            }
            else if (newMessageToCurrentChannel &&
                mainChannelUpdated &&
                !isOwnMessage &&
                shouldMarkRead(channel.countUnread())) {
                markRead();
            }
        };
        client.on('message.new', handleMessageNew);
        document.addEventListener('visibilitychange', onVisibilityChange);
        var hasScrolledToBottom = previousRenderMessageListScrolledToBottom.current !== isMessageListScrolledToBottom &&
            isMessageListScrolledToBottom;
        if (shouldMarkRead(hasScrolledToBottom ? channel.countUnread() : unreadCount))
            markRead();
        previousRenderMessageListScrolledToBottom.current = isMessageListScrolledToBottom;
        return function () {
            client.off('message.new', handleMessageNew);
            document.removeEventListener('visibilitychange', onVisibilityChange);
        };
    }, [
        channel,
        client,
        isMessageListScrolledToBottom,
        markRead,
        messageListIsThread,
        setChannelUnreadUiState,
        unreadCount,
        wasMarkedUnread,
    ]);
};
function getPreviousLastMessage(messages, newMessage) {
    if (!newMessage)
        return;
    var previousLastMessage;
    for (var i = messages.length - 1; i >= 0; i--) {
        var msg = messages[i];
        if (!(msg === null || msg === void 0 ? void 0 : msg.id))
            break;
        if (msg.id !== newMessage.id) {
            previousLastMessage = msg;
            break;
        }
    }
    return previousLastMessage;
}

var MessageListNotifications = function (props) {
    var hasNewMessages = props.hasNewMessages, isMessageListScrolledToBottom = props.isMessageListScrolledToBottom, isNotAtLatestMessageSet = props.isNotAtLatestMessageSet, MessageNotification = props.MessageNotification, notifications = props.notifications, scrollToBottom = props.scrollToBottom, threadList = props.threadList, unreadCount = props.unreadCount;
    var t = Window.useTranslationContext('MessageListNotifications').t;
    return (React__default["default"].createElement("div", { className: 'str-chat__list-notifications' },
        notifications.map(function (notification) { return (React__default["default"].createElement(Window.CustomNotification, { active: true, key: notification.id, type: notification.type }, notification.text)); }),
        React__default["default"].createElement(Window.ConnectionStatus, null),
        React__default["default"].createElement(MessageNotification, { isMessageListScrolledToBottom: isMessageListScrolledToBottom, onClick: scrollToBottom, showNotification: hasNewMessages || isNotAtLatestMessageSet, threadList: threadList, unreadCount: unreadCount }, isNotAtLatestMessageSet ? t('Latest Messages') : t('New Messages!'))));
};

var UnreadMessagesNotification = function (_a) {
    var queryMessageLimit = _a.queryMessageLimit, showCount = _a.showCount, unreadCount = _a.unreadCount;
    var _b = Window.useChannelActionContext('UnreadMessagesNotification'), jumpToFirstUnreadMessage = _b.jumpToFirstUnreadMessage, markRead = _b.markRead;
    var t = Window.useTranslationContext('UnreadMessagesNotification').t;
    return (React__default["default"].createElement("div", { className: 'str-chat__unread-messages-notification', "data-testid": 'unread-messages-notification' },
        React__default["default"].createElement("button", { onClick: function () { return jumpToFirstUnreadMessage(queryMessageLimit); } }, unreadCount && showCount
            ? t('{{count}} unread', { count: unreadCount !== null && unreadCount !== void 0 ? unreadCount : 0 })
            : t('Unread messages')),
        React__default["default"].createElement("button", { onClick: function () { return markRead(); } },
            React__default["default"].createElement(Window.CloseIcon, null))));
};

/**
 * Prevents Chrome hangups
 * See: https://stackoverflow.com/questions/47524205/random-high-content-download-time-in-chrome/47684257#47684257
 */
var mousewheelListener = function (event) {
    if (event instanceof WheelEvent && event.deltaY === 1) {
        event.preventDefault();
    }
};
var InfiniteScroll = function (props) {
    var children = props.children, _a = props.element, element = _a === void 0 ? 'div' : _a, hasMore = props.hasMore, hasMoreNewer = props.hasMoreNewer, hasNextPage = props.hasNextPage, hasPreviousPage = props.hasPreviousPage, head = props.head, _b = props.initialLoad, initialLoad = _b === void 0 ? true : _b, isLoading = props.isLoading, listenToScroll = props.listenToScroll, loader = props.loader, loadMore = props.loadMore, loadMoreNewer = props.loadMoreNewer, loadNextPage = props.loadNextPage, loadPreviousPage = props.loadPreviousPage, _c = props.threshold, threshold = _c === void 0 ? Window.DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD : _c, _d = props.useCapture, useCapture = _d === void 0 ? false : _d, elementProps = Window.__rest(props, ["children", "element", "hasMore", "hasMoreNewer", "hasNextPage", "hasPreviousPage", "head", "initialLoad", "isLoading", "listenToScroll", "loader", "loadMore", "loadMoreNewer", "loadNextPage", "loadPreviousPage", "threshold", "useCapture"]);
    var loadNextPageFn = loadNextPage || loadMoreNewer;
    var loadPreviousPageFn = loadPreviousPage || loadMore;
    var hasNextPageFlag = hasNextPage || hasMoreNewer;
    var hasPreviousPageFlag = hasPreviousPage || hasMore;
    var scrollComponent = React.useRef();
    var scrollListenerRef = React.useRef();
    scrollListenerRef.current = function () {
        var element = scrollComponent.current;
        if (!element || element.offsetParent === null) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        var parentElement = element.parentElement;
        var offset = element.scrollHeight - parentElement.scrollTop - parentElement.clientHeight;
        var reverseOffset = parentElement.scrollTop;
        if (listenToScroll) {
            listenToScroll(offset, reverseOffset, threshold);
        }
        if (isLoading)
            return;
        // FIXME: this triggers loadMore call when a user types messages in thread and the scroll container container expands
        if (reverseOffset < Number(threshold) &&
            typeof loadPreviousPageFn === 'function' &&
            hasPreviousPageFlag) {
            loadPreviousPageFn();
        }
        if (offset < Number(threshold) && typeof loadNextPageFn === 'function' && hasNextPageFlag) {
            loadNextPageFn();
        }
    };
    React.useEffect(function () {
        Window.deprecationAndReplacementWarning([
            [{ hasMoreNewer: hasMoreNewer }, { hasNextPage: hasNextPage }],
            [{ loadMoreNewer: loadMoreNewer }, { loadNextPage: loadNextPage }],
            [{ hasMore: hasMore }, { hasPreviousPage: hasPreviousPage }],
            [{ loadMore: loadMore }, { loadPreviousPage: loadPreviousPage }],
        ], 'InfiniteScroll');
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    React.useLayoutEffect(function () {
        var _a;
        var scrollElement = (_a = scrollComponent.current) === null || _a === void 0 ? void 0 : _a.parentNode;
        if (!scrollElement)
            return;
        var scrollListener = function () { var _a; return (_a = scrollListenerRef.current) === null || _a === void 0 ? void 0 : _a.call(scrollListenerRef); };
        scrollElement.addEventListener('scroll', scrollListener, useCapture);
        scrollElement.addEventListener('resize', scrollListener, useCapture);
        scrollListener();
        return function () {
            scrollElement.removeEventListener('scroll', scrollListener, useCapture);
            scrollElement.removeEventListener('resize', scrollListener, useCapture);
        };
    }, [initialLoad, useCapture]);
    React.useEffect(function () {
        var _a;
        var scrollElement = (_a = scrollComponent.current) === null || _a === void 0 ? void 0 : _a.parentNode;
        if (scrollElement) {
            scrollElement.addEventListener('wheel', mousewheelListener, { passive: false });
        }
        return function () {
            if (scrollElement) {
                scrollElement.removeEventListener('wheel', mousewheelListener, useCapture);
            }
        };
    }, [useCapture]);
    var attributes = Window.__assign(Window.__assign({}, elementProps), { ref: function (element) {
            scrollComponent.current = element;
        } });
    var childrenArray = [loader, children];
    if (head) {
        childrenArray.unshift(head);
    }
    return React__default["default"].createElement(element, attributes, childrenArray);
};

function defaultRenderMessages(_a) {
    var channelUnreadUiState = _a.channelUnreadUiState, components = _a.components, customClasses = _a.customClasses, lastReceivedId = _a.lastReceivedMessageId, messageGroupStyles = _a.messageGroupStyles, messages = _a.messages, readData = _a.readData, messageProps = _a.sharedMessageProps;
    var DateSeparator = components.DateSeparator, HeaderComponent = components.HeaderComponent, MessageSystem = components.MessageSystem, UnreadMessagesSeparator = components.UnreadMessagesSeparator;
    return messages.map(function (message, index) {
        if (message.customType === Window.CUSTOM_MESSAGE_TYPE.date && message.date && Window.isDate(message.date)) {
            return (React__default["default"].createElement("li", { key: "".concat(message.date.toISOString(), "-i") },
                React__default["default"].createElement(DateSeparator, { date: message.date, formatDate: messageProps.formatDate, unread: message.unread })));
        }
        if (message.customType === Window.CUSTOM_MESSAGE_TYPE.intro && HeaderComponent) {
            return (React__default["default"].createElement("li", { key: 'intro' },
                React__default["default"].createElement(HeaderComponent, null)));
        }
        if (message.type === 'system') {
            return (React__default["default"].createElement("li", { key: message.id || message.created_at },
                React__default["default"].createElement(MessageSystem, { message: message })));
        }
        var groupStyles = messageGroupStyles[message.id] || '';
        var messageClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.message) || "str-chat__li str-chat__li--".concat(groupStyles);
        var isNewestMessage = index === messages.length - 1;
        var isLastReadMessage = (channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read_message_id) === message.id;
        var showUnreadSeparator = isLastReadMessage &&
            !isNewestMessage &&
            ((channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id) || (channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages) > 0); // unread count can be 0 if the user marks unread only own messages
        return (React__default["default"].createElement(React.Fragment, { key: message.id || message.created_at },
            React__default["default"].createElement("li", { className: messageClass, "data-message-id": message.id, "data-testid": messageClass },
                React__default["default"].createElement(Window.Message, Window.__assign({ groupStyles: [groupStyles], lastReceivedId: lastReceivedId, message: message, readBy: readData[message.id] || [] }, messageProps))),
            showUnreadSeparator && UnreadMessagesSeparator && (React__default["default"].createElement("li", { className: 'str-chat__li str-chat__unread-messages-separator-wrapper' },
                React__default["default"].createElement(UnreadMessagesSeparator, { unreadCount: channelUnreadUiState.unread_messages })))));
    });
}

var MessageListWithContext = function (props) {
    var _a;
    var channel = props.channel, channelUnreadUiState = props.channelUnreadUiState, _b = props.disableDateSeparator, disableDateSeparator = _b === void 0 ? false : _b, groupStyles = props.groupStyles, _c = props.hideDeletedMessages, hideDeletedMessages = _c === void 0 ? false : _c, _d = props.hideNewMessageSeparator, hideNewMessageSeparator = _d === void 0 ? false : _d, _e = props.internalInfiniteScrollProps, _f = _e === void 0 ? {} : _e, _g = _f.threshold, loadMoreScrollThreshold = _g === void 0 ? Window.DEFAULT_LOAD_PAGE_SCROLL_THRESHOLD : _g, restInternalInfiniteScrollProps = Window.__rest(_f, ["threshold"]), _h = props.messageActions, messageActions = _h === void 0 ? Object.keys(Window.MESSAGE_ACTIONS) : _h, _j = props.messages, messages = _j === void 0 ? [] : _j, notifications = props.notifications, _k = props.noGroupByUser, noGroupByUser = _k === void 0 ? false : _k, _l = props.pinPermissions, pinPermissions = _l === void 0 ? Window.defaultPinPermissions : _l, // @deprecated in favor of `channelCapabilities` - TODO: remove in next major release
    _m = props.returnAllReadData, // @deprecated in favor of `channelCapabilities` - TODO: remove in next major release
    returnAllReadData = _m === void 0 ? false : _m, _o = props.threadList, threadList = _o === void 0 ? false : _o, _p = props.unsafeHTML, unsafeHTML = _p === void 0 ? false : _p, headerPosition = props.headerPosition, read = props.read, _q = props.renderMessages, renderMessages = _q === void 0 ? defaultRenderMessages : _q, _r = props.messageLimit, messageLimit = _r === void 0 ? Window.DEFAULT_NEXT_CHANNEL_PAGE_SIZE : _r, loadMoreCallback = props.loadMore, loadMoreNewerCallback = props.loadMoreNewer, _s = props.hasMoreNewer, hasMoreNewer = _s === void 0 ? false : _s, showUnreadNotificationAlways = props.showUnreadNotificationAlways, suppressAutoscroll = props.suppressAutoscroll, highlightedMessageId = props.highlightedMessageId, _t = props.jumpToLatestMessage, jumpToLatestMessage = _t === void 0 ? function () { return Promise.resolve(); } : _t;
    var _u = React__default["default"].useState(null), listElement = _u[0], setListElement = _u[1];
    var _v = React__default["default"].useState(null), ulElement = _v[0], setUlElement = _v[1];
    var customClasses = Window.useChatContext('MessageList').customClasses;
    var _w = Window.useComponentContext('MessageList'), _x = _w.EmptyStateIndicator, EmptyStateIndicator = _x === void 0 ? Window.EmptyStateIndicator : _x, _y = _w.LoadingIndicator, LoadingIndicator = _y === void 0 ? Window.LoadingIndicator : _y, _z = _w.MessageListNotifications, MessageListNotifications$1 = _z === void 0 ? MessageListNotifications : _z, _0 = _w.MessageNotification, MessageNotification = _0 === void 0 ? Window.MessageNotification : _0, _1 = _w.TypingIndicator, TypingIndicator = _1 === void 0 ? Window.TypingIndicator : _1, _2 = _w.UnreadMessagesNotification, UnreadMessagesNotification$1 = _2 === void 0 ? UnreadMessagesNotification : _2;
    var _3 = useScrollLocationLogic({
        hasMoreNewer: hasMoreNewer,
        listElement: listElement,
        loadMoreScrollThreshold: loadMoreScrollThreshold,
        messages: messages,
        scrolledUpThreshold: props.scrolledUpThreshold,
        suppressAutoscroll: suppressAutoscroll,
    }), hasNewMessages = _3.hasNewMessages, isMessageListScrolledToBottom = _3.isMessageListScrolledToBottom, onScroll = _3.onScroll, scrollToBottom = _3.scrollToBottom, wrapperRect = _3.wrapperRect;
    var showUnreadMessagesNotification = useUnreadMessagesNotification({
        isMessageListScrolledToBottom: isMessageListScrolledToBottom,
        showAlways: !!showUnreadNotificationAlways,
        unreadCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages,
    }).show;
    useMarkRead({
        isMessageListScrolledToBottom: isMessageListScrolledToBottom,
        messageListIsThread: threadList,
        unreadCount: (_a = channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages) !== null && _a !== void 0 ? _a : 0,
        wasMarkedUnread: !!(channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id),
    });
    var _4 = useEnrichedMessages({
        channel: channel,
        disableDateSeparator: disableDateSeparator,
        groupStyles: groupStyles,
        headerPosition: headerPosition,
        hideDeletedMessages: hideDeletedMessages,
        hideNewMessageSeparator: hideNewMessageSeparator,
        messages: messages,
        noGroupByUser: noGroupByUser,
    }), messageGroupStyles = _4.messageGroupStyles, enrichedMessages = _4.messages;
    var elements = useMessageListElements({
        channelUnreadUiState: channelUnreadUiState,
        enrichedMessages: enrichedMessages,
        internalMessageProps: {
            additionalMessageInputProps: props.additionalMessageInputProps,
            closeReactionSelectorOnClick: props.closeReactionSelectorOnClick,
            customMessageActions: props.customMessageActions,
            disableQuotedMessages: props.disableQuotedMessages,
            formatDate: props.formatDate,
            getDeleteMessageErrorNotification: props.getDeleteMessageErrorNotification,
            getFlagMessageErrorNotification: props.getFlagMessageErrorNotification,
            getFlagMessageSuccessNotification: props.getFlagMessageSuccessNotification,
            getMarkMessageUnreadErrorNotification: props.getMarkMessageUnreadErrorNotification,
            getMarkMessageUnreadSuccessNotification: props.getMarkMessageUnreadSuccessNotification,
            getMuteUserErrorNotification: props.getMuteUserErrorNotification,
            getMuteUserSuccessNotification: props.getMuteUserSuccessNotification,
            getPinMessageErrorNotification: props.getPinMessageErrorNotification,
            Message: props.Message,
            messageActions: messageActions,
            messageListRect: wrapperRect,
            onlySenderCanEdit: props.onlySenderCanEdit,
            onMentionsClick: props.onMentionsClick,
            onMentionsHover: props.onMentionsHover,
            onUserClick: props.onUserClick,
            onUserHover: props.onUserHover,
            openThread: props.openThread,
            pinPermissions: pinPermissions,
            renderText: props.renderText,
            retrySendMessage: props.retrySendMessage,
            unsafeHTML: unsafeHTML,
        },
        messageGroupStyles: messageGroupStyles,
        read: read,
        renderMessages: renderMessages,
        returnAllReadData: returnAllReadData,
        threadList: threadList,
    });
    var messageListClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.messageList) || 'str-chat__list';
    var threadListClass = threadList
        ? (customClasses === null || customClasses === void 0 ? void 0 : customClasses.threadList) || 'str-chat__list--thread str-chat__thread-list'
        : '';
    var loadMore = React__default["default"].useCallback(function () {
        if (loadMoreCallback) {
            loadMoreCallback(messageLimit);
        }
    }, [loadMoreCallback, messageLimit]);
    var loadMoreNewer = React__default["default"].useCallback(function () {
        if (loadMoreNewerCallback) {
            loadMoreNewerCallback(messageLimit);
        }
    }, [loadMoreNewerCallback, messageLimit]);
    var scrollToBottomFromNotification = React__default["default"].useCallback(function () { return Window.__awaiter(void 0, void 0, void 0, function () {
        return Window.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!hasMoreNewer) return [3 /*break*/, 2];
                    return [4 /*yield*/, jumpToLatestMessage()];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    scrollToBottom();
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); }, [scrollToBottom, hasMoreNewer]);
    React__default["default"].useLayoutEffect(function () {
        if (highlightedMessageId) {
            var element = ulElement === null || ulElement === void 0 ? void 0 : ulElement.querySelector("[data-message-id='".concat(highlightedMessageId, "']"));
            element === null || element === void 0 ? void 0 : element.scrollIntoView({ block: 'center' });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [highlightedMessageId]);
    var showEmptyStateIndicator = elements.length === 0 && !threadList;
    return (React__default["default"].createElement(Window.MessageListContextProvider, { value: { listElement: listElement, scrollToBottom: scrollToBottom } },
        React__default["default"].createElement(MessageListMainPanel, null,
            !threadList && showUnreadMessagesNotification && (React__default["default"].createElement(UnreadMessagesNotification$1, { unreadCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages })),
            React__default["default"].createElement("div", { className: "".concat(messageListClass, " ").concat(threadListClass), onScroll: onScroll, ref: setListElement, tabIndex: 0 }, showEmptyStateIndicator ? (React__default["default"].createElement(EmptyStateIndicator, { key: 'empty-state-indicator', listType: threadList ? 'thread' : 'message' })) : (React__default["default"].createElement(InfiniteScroll, Window.__assign({ className: 'str-chat__reverse-infinite-scroll  str-chat__message-list-scroll', "data-testid": 'reverse-infinite-scroll', hasNextPage: props.hasMoreNewer, hasPreviousPage: props.hasMore, head: props.head, isLoading: props.loadingMore, loader: React__default["default"].createElement("div", { className: 'str-chat__list__loading', key: 'loading-indicator' }, props.loadingMore && React__default["default"].createElement(LoadingIndicator, { size: 20 })), loadNextPage: loadMoreNewer, loadPreviousPage: loadMore, threshold: loadMoreScrollThreshold }, restInternalInfiniteScrollProps),
                React__default["default"].createElement("ul", { className: 'str-chat__ul', ref: setUlElement }, elements),
                React__default["default"].createElement(TypingIndicator, { threadList: threadList }),
                React__default["default"].createElement("div", { key: 'bottom' }))))),
        React__default["default"].createElement(MessageListNotifications$1, { hasNewMessages: hasNewMessages, isMessageListScrolledToBottom: isMessageListScrolledToBottom, isNotAtLatestMessageSet: hasMoreNewer, MessageNotification: MessageNotification, notifications: notifications, scrollToBottom: scrollToBottomFromNotification, threadList: threadList, unreadCount: threadList ? undefined : channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages })));
};
/**
 * The MessageList component renders a list of Messages.
 * It is a consumer of the following contexts:
 * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)
 * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)
 * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)
 * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)
 */
var MessageList = function (props) {
    var _a = Window.useChannelActionContext('MessageList'), jumpToLatestMessage = _a.jumpToLatestMessage, loadMore = _a.loadMore, loadMoreNewer = _a.loadMoreNewer;
    var _b = Window.useChannelStateContext('MessageList'); _b.members; // eslint-disable-line @typescript-eslint/no-unused-vars
    _b.mutes; // eslint-disable-line @typescript-eslint/no-unused-vars
    _b.watchers; // eslint-disable-line @typescript-eslint/no-unused-vars
    var restChannelStateContext = Window.__rest(_b, ["members", "mutes", "watchers"]);
    return (React__default["default"].createElement(MessageListWithContext, Window.__assign({ jumpToLatestMessage: jumpToLatestMessage, loadMore: loadMore, loadMoreNewer: loadMoreNewer }, restChannelStateContext, props)));
};

function useNewMessageNotification(messages, currentUserId, hasMoreNewer) {
    var _a = React.useState(false), newMessagesNotification = _a[0], setNewMessagesNotification = _a[1];
    var _b = React.useState(true), isMessageListScrolledToBottom = _b[0], setIsMessageListScrolledToBottom = _b[1];
    /**
     * use the flag to avoid the initial "new messages" quick blink
     */
    var didMount = React.useRef(false);
    var lastMessageId = React.useRef('');
    var atBottom = React.useRef(false);
    React.useEffect(function () {
        var _a;
        if (hasMoreNewer) {
            setNewMessagesNotification(true);
            return;
        }
        /* handle scrolling behavior for new messages */
        if (!(messages === null || messages === void 0 ? void 0 : messages.length))
            return;
        var lastMessage = messages[messages.length - 1];
        var prevMessageId = lastMessageId.current;
        lastMessageId.current = lastMessage.id || ''; // update last message id
        /* do nothing if new messages are loaded from top(loadMore)  */
        if (lastMessage.id === prevMessageId)
            return;
        /* if list is already at the bottom return, followOutput will do the job */
        if (atBottom.current)
            return;
        /* if the new message belongs to current user scroll to bottom */
        if (((_a = lastMessage.user) === null || _a === void 0 ? void 0 : _a.id) !== currentUserId && didMount.current) {
            /* otherwise just show newMessage notification  */
            setNewMessagesNotification(true);
        }
        didMount.current = true;
    }, [currentUserId, messages, hasMoreNewer]);
    return {
        atBottom: atBottom,
        isMessageListScrolledToBottom: isMessageListScrolledToBottom,
        newMessagesNotification: newMessagesNotification,
        setIsMessageListScrolledToBottom: setIsMessageListScrolledToBottom,
        setNewMessagesNotification: setNewMessagesNotification,
    };
}

var STATUSES_EXCLUDED_FROM_PREPEND = {
    failed: true,
    sending: true,
};
function usePrependedMessagesCount(messages, hasDateSeparator) {
    var firstRealMessageIndex = hasDateSeparator ? 1 : 0;
    var firstMessageOnFirstLoadedPage = React.useRef();
    var previousFirstMessageOnFirstLoadedPage = React.useRef();
    var previousNumItemsPrepended = React.useRef(0);
    var numItemsPrepended = React.useMemo(function () {
        var _a, _b;
        if (!messages || !messages.length) {
            previousNumItemsPrepended.current = 0;
            return 0;
        }
        var currentFirstMessage = messages === null || messages === void 0 ? void 0 : messages[firstRealMessageIndex];
        var noNewMessages = (currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.id) === ((_a = previousFirstMessageOnFirstLoadedPage.current) === null || _a === void 0 ? void 0 : _a.id);
        // This is possible only, when sending messages very quickly (basically single char messages submitted like a crazy) in empty channel (first page)
        // Optimistic UI update, when sending messages, can lead to a situation, when
        // the order of the messages changes for a moment. This can happen, when a user
        // sends multiple messages withing few milliseconds. E.g. we send a message A
        // then message B. At first we have message array with both messages of status "sending"
        // then response for message A is received with a new - later - created_at timestamp
        // this leads to rearrangement of 1.B ("sending"), 2.A ("received"). Still firstMessageOnFirstLoadedPage.current
        // points to message A, but now this message has index 1 => previousNumItemsPrepended.current === 1
        // That in turn leads to incorrect index calculation in VirtualizedMessageList trying to access a message
        // at non-existent index. Therefore, we ignore messages of status "sending" / "failed" in order they are
        // not considered as prepended messages.
        var firstMsgMovedAfterMessagesInExcludedStatus = !!((currentFirstMessage === null || currentFirstMessage === void 0 ? void 0 : currentFirstMessage.status) && STATUSES_EXCLUDED_FROM_PREPEND[currentFirstMessage.status]);
        if (noNewMessages || firstMsgMovedAfterMessagesInExcludedStatus) {
            return previousNumItemsPrepended.current;
        }
        if (!firstMessageOnFirstLoadedPage.current) {
            firstMessageOnFirstLoadedPage.current = currentFirstMessage;
        }
        previousFirstMessageOnFirstLoadedPage.current = currentFirstMessage;
        // if new messages were prepended, find out how many
        // start with this number because there cannot be fewer prepended items than before
        for (var prependedMessageCount = previousNumItemsPrepended.current; prependedMessageCount < messages.length; prependedMessageCount += 1) {
            var messageIsFirstOnFirstLoadedPage = messages[prependedMessageCount].id === ((_b = firstMessageOnFirstLoadedPage.current) === null || _b === void 0 ? void 0 : _b.id);
            if (messageIsFirstOnFirstLoadedPage) {
                previousNumItemsPrepended.current = prependedMessageCount - firstRealMessageIndex;
                return previousNumItemsPrepended.current;
            }
        }
        // if no match has found, we have jumped - reset the prepended item count.
        firstMessageOnFirstLoadedPage.current = currentFirstMessage;
        previousNumItemsPrepended.current = 0;
        return 0;
        // TODO: there's a bug here, the messages prop is the same array instance (something mutates it)
        // that's why the second dependency is necessary
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [firstRealMessageIndex, messages, messages === null || messages === void 0 ? void 0 : messages.length]);
    return numItemsPrepended;
}

function useShouldForceScrollToBottom(messages, currentUserId) {
    var lastFocusedOwnMessage = React.useRef('');
    var initialFocusRegistered = React.useRef(false);
    function recheckForNewOwnMessage() {
        var _a;
        if (messages && messages.length > 0) {
            var lastMessage = messages[messages.length - 1];
            if (((_a = lastMessage.user) === null || _a === void 0 ? void 0 : _a.id) === currentUserId &&
                lastFocusedOwnMessage.current !== lastMessage.id) {
                lastFocusedOwnMessage.current = lastMessage.id;
                return true;
            }
        }
        return false;
    }
    React.useEffect(function () {
        if (messages && messages.length && !initialFocusRegistered.current) {
            initialFocusRegistered.current = true;
            recheckForNewOwnMessage();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [messages, messages === null || messages === void 0 ? void 0 : messages.length]);
    return recheckForNewOwnMessage;
}

var useGiphyPreview = function (separateGiphyPreview) {
    var _a = React.useState(), giphyPreviewMessage = _a[0], setGiphyPreviewMessage = _a[1];
    var client = Window.useChatContext('useGiphyPreview').client;
    React.useEffect(function () {
        var handleEvent = function (event) {
            var message = event.message, user = event.user;
            if ((message === null || message === void 0 ? void 0 : message.command) === 'giphy' && (user === null || user === void 0 ? void 0 : user.id) === client.userID) {
                setGiphyPreviewMessage(undefined);
            }
        };
        if (separateGiphyPreview)
            client.on('message.new', handleEvent);
        return function () { return client.off('message.new', handleEvent); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [separateGiphyPreview]);
    return { giphyPreviewMessage: giphyPreviewMessage, setGiphyPreviewMessage: setGiphyPreviewMessage };
};

var useMessageSetKey = function (_a) {
    var messages = _a.messages;
    /**
     * Logic to update the key of the virtuoso component when the list jumps to a new location.
     */
    var _b = React.useState(+new Date()), messageSetKey = _b[0], setMessageSetKey = _b[1];
    var firstMessageId = React.useRef();
    React.useEffect(function () {
        var _a;
        var continuousSet = messages === null || messages === void 0 ? void 0 : messages.find(function (message) { return message.id === firstMessageId.current; });
        if (!continuousSet) {
            setMessageSetKey(+new Date());
        }
        firstMessageId.current = (_a = messages === null || messages === void 0 ? void 0 : messages[0]) === null || _a === void 0 ? void 0 : _a.id;
    }, [messages]);
    return {
        messageSetKey: messageSetKey,
    };
};

var useScrollToBottomOnNewMessage = function (_a) {
    var messages = _a.messages, scrollToBottom = _a.scrollToBottom, scrollToLatestMessageOnFocus = _a.scrollToLatestMessageOnFocus;
    var _b = React__default["default"].useState(false), newMessagesReceivedInBackground = _b[0], setNewMessagesReceivedInBackground = _b[1];
    var resetNewMessagesReceivedInBackground = React.useCallback(function () {
        setNewMessagesReceivedInBackground(false);
    }, []);
    React.useEffect(function () {
        setNewMessagesReceivedInBackground(true);
    }, [messages]);
    var scrollToBottomIfConfigured = React.useCallback(function (event) {
        if (!scrollToLatestMessageOnFocus ||
            !newMessagesReceivedInBackground ||
            event.target !== window)
            return;
        setTimeout(scrollToBottom, 100);
    }, [scrollToLatestMessageOnFocus, scrollToBottom, newMessagesReceivedInBackground]);
    React.useEffect(function () {
        if (typeof window !== 'undefined') {
            window.addEventListener('focus', scrollToBottomIfConfigured);
            window.addEventListener('blur', resetNewMessagesReceivedInBackground);
        }
        return function () {
            window.removeEventListener('focus', scrollToBottomIfConfigured);
            window.removeEventListener('blur', resetNewMessagesReceivedInBackground);
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [scrollToBottomIfConfigured]);
};

/**
 * Controls the logic when an `UnreadMessagesNotification` component should be shown.
 * In virtualized message list there is no notion of being scrolled below or above `UnreadMessagesSeparator`.
 * Therefore, the `UnreadMessagesNotification` component is rendered based on timestamps.
 * If the there are unread messages in the channel and the `VirtualizedMessageList` renders
 * messages created later than the last read message in the channel, then the
 * `UnreadMessagesNotification` component is rendered. This is an approximate equivalent to being
 * scrolled below the `UnreadMessagesNotification` component.
 * @param lastRead
 * @param showAlways
 * @param unreadCount
 */
var useUnreadMessagesNotificationVirtualized = function (_a) {
    var lastRead = _a.lastRead, showAlways = _a.showAlways, unreadCount = _a.unreadCount;
    var _b = React.useState(false), show = _b[0], setShow = _b[1];
    var toggleShowUnreadMessagesNotification = React.useCallback(function (renderedMessages) {
        if (!unreadCount)
            return;
        var firstRenderedMessage = renderedMessages[0];
        var lastRenderedMessage = renderedMessages.slice(-1)[0];
        if (!(firstRenderedMessage && lastRenderedMessage))
            return;
        var scrolledBelowSeparator = !!lastRead &&
            new Date(firstRenderedMessage.created_at).getTime() > lastRead.getTime();
        var scrolledAboveSeparator = !!lastRead &&
            new Date(lastRenderedMessage.created_at).getTime() < lastRead.getTime();
        setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);
    }, [lastRead, showAlways, unreadCount]);
    React.useEffect(function () {
        if (!unreadCount)
            setShow(false);
    }, [unreadCount]);
    return { show: show, toggleShowUnreadMessagesNotification: toggleShowUnreadMessagesNotification };
};

var PREPEND_OFFSET = Math.pow(10, 7);
function calculateItemIndex(virtuosoIndex, numItemsPrepended) {
    return virtuosoIndex + numItemsPrepended - PREPEND_OFFSET;
}
function calculateFirstItemIndex(numItemsPrepended) {
    return PREPEND_OFFSET - numItemsPrepended;
}
var makeItemsRenderedHandler = function (renderedItemsActions, processedMessages) {
    return throttle__default["default"](function (items) {
        var renderedMessages = items
            .map(function (item) {
            if (!item.originalIndex)
                return undefined;
            return processedMessages[calculateItemIndex(item.originalIndex, PREPEND_OFFSET)];
        })
            .filter(function (msg) { return !!msg; });
        renderedItemsActions.forEach(function (action) {
            return action(renderedMessages);
        });
    }, 200);
};
// using 'display: inline-block'
// traps CSS margins of the item elements, preventing incorrect item measurements
var Item = function (_a) {
    var _b;
    var _c;
    var context = _a.context, props = Window.__rest(_a, ["context"]);
    if (!context)
        return React__default["default"].createElement(React__default["default"].Fragment, null);
    var message = context.processedMessages[calculateItemIndex(props['data-item-index'], context.numItemsPrepended)];
    var groupStyles = context.messageGroupStyles[message.id];
    return (React__default["default"].createElement("div", Window.__assign({}, props, { className: ((_c = context === null || context === void 0 ? void 0 : context.customClasses) === null || _c === void 0 ? void 0 : _c.virtualMessage) ||
            Window.clsx('str-chat__virtual-list-message-wrapper str-chat__li', (_b = {},
                _b["str-chat__li--".concat(groupStyles)] = groupStyles,
                _b)) })));
};
var Header = function (_a) {
    var context = _a.context;
    var _b = Window.useComponentContext('VirtualizedMessageListHeader').LoadingIndicator, LoadingIndicator = _b === void 0 ? Window.LoadingIndicator : _b;
    if (!(context === null || context === void 0 ? void 0 : context.loadingMore))
        return null;
    return LoadingIndicator ? (React__default["default"].createElement("div", { className: 'str-chat__virtual-list__loading' },
        React__default["default"].createElement(LoadingIndicator, { size: 20 }))) : ((context === null || context === void 0 ? void 0 : context.head) || null);
};
var EmptyPlaceholder = function (_a) {
    var context = _a.context;
    var _b = Window.useComponentContext('VirtualizedMessageList').EmptyStateIndicator, EmptyStateIndicator = _b === void 0 ? Window.EmptyStateIndicator : _b;
    return (React__default["default"].createElement(React__default["default"].Fragment, null, EmptyStateIndicator && (React__default["default"].createElement(EmptyStateIndicator, { listType: (context === null || context === void 0 ? void 0 : context.threadList) ? 'thread' : 'message' }))));
};
var Footer = function () {
    var TypingIndicator = Window.useComponentContext('VirtualizedMessageList').TypingIndicator;
    return TypingIndicator ? React__default["default"].createElement(TypingIndicator, { avatarSize: 24 }) : null;
};
var messageRenderer = function (virtuosoIndex, _data, virtuosoContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var additionalMessageInputProps = virtuosoContext.additionalMessageInputProps, closeReactionSelectorOnClick = virtuosoContext.closeReactionSelectorOnClick, customMessageActions = virtuosoContext.customMessageActions, customMessageRenderer = virtuosoContext.customMessageRenderer, DateSeparator = virtuosoContext.DateSeparator, firstUnreadMessageId = virtuosoContext.firstUnreadMessageId, lastReadMessageId = virtuosoContext.lastReadMessageId, lastReceivedMessageId = virtuosoContext.lastReceivedMessageId, MessageUIComponent = virtuosoContext.Message, messageActions = virtuosoContext.messageActions, MessageSystem = virtuosoContext.MessageSystem, numItemsPrepended = virtuosoContext.numItemsPrepended, ownMessagesReadByOthers = virtuosoContext.ownMessagesReadByOthers, messageList = virtuosoContext.processedMessages, shouldGroupByUser = virtuosoContext.shouldGroupByUser, sortReactionDetails = virtuosoContext.sortReactionDetails, sortReactions = virtuosoContext.sortReactions, _k = virtuosoContext.unreadMessageCount, unreadMessageCount = _k === void 0 ? 0 : _k, UnreadMessagesSeparator = virtuosoContext.UnreadMessagesSeparator, virtuosoRef = virtuosoContext.virtuosoRef;
    var streamMessageIndex = calculateItemIndex(virtuosoIndex, numItemsPrepended);
    if (customMessageRenderer) {
        return customMessageRenderer(messageList, streamMessageIndex);
    }
    var message = messageList[streamMessageIndex];
    if (!message)
        return React__default["default"].createElement("div", { style: { height: '1px' } }); // returning null or zero height breaks the virtuoso
    if (message.customType === Window.CUSTOM_MESSAGE_TYPE.date && message.date && Window.isDate(message.date)) {
        return DateSeparator ? React__default["default"].createElement(DateSeparator, { date: message.date, unread: message.unread }) : null;
    }
    if (message.type === 'system') {
        return MessageSystem ? React__default["default"].createElement(MessageSystem, { message: message }) : null;
    }
    var groupedByUser = shouldGroupByUser &&
        streamMessageIndex > 0 &&
        ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = messageList[streamMessageIndex - 1].user) === null || _b === void 0 ? void 0 : _b.id);
    var firstOfGroup = shouldGroupByUser && ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_e = (_d = messageList[streamMessageIndex - 1]) === null || _d === void 0 ? void 0 : _d.user) === null || _e === void 0 ? void 0 : _e.id);
    var endOfGroup = shouldGroupByUser && ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_h = (_g = messageList[streamMessageIndex + 1]) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.id);
    var isNewestMessage = lastReadMessageId === lastReceivedMessageId;
    var isLastReadMessage = message.id === lastReadMessageId;
    var showUnreadSeparator = isLastReadMessage && !isNewestMessage && (firstUnreadMessageId || unreadMessageCount > 0); // unread count can be 0 if the user marks unread only own messages
    return (React__default["default"].createElement(React__default["default"].Fragment, null,
        React__default["default"].createElement(Window.Message, { additionalMessageInputProps: additionalMessageInputProps, autoscrollToBottom: (_j = virtuosoRef.current) === null || _j === void 0 ? void 0 : _j.autoscrollToBottom, closeReactionSelectorOnClick: closeReactionSelectorOnClick, customMessageActions: customMessageActions, endOfGroup: endOfGroup, firstOfGroup: firstOfGroup, groupedByUser: groupedByUser, lastReceivedId: lastReceivedMessageId, message: message, Message: MessageUIComponent, messageActions: messageActions, readBy: ownMessagesReadByOthers[message.id] || [], sortReactionDetails: sortReactionDetails, sortReactions: sortReactions }),
        showUnreadSeparator && (React__default["default"].createElement("div", { className: 'str-chat__unread-messages-separator-wrapper' },
            React__default["default"].createElement(UnreadMessagesSeparator, { unreadCount: unreadMessageCount })))));
};

function captureResizeObserverExceededError(e) {
    if (e.message === 'ResizeObserver loop completed with undelivered notifications.' ||
        e.message === 'ResizeObserver loop limit exceeded') {
        e.stopImmediatePropagation();
    }
}
function useCaptureResizeObserverExceededError() {
    React.useEffect(function () {
        window.addEventListener('error', captureResizeObserverExceededError);
        return function () {
            window.removeEventListener('error', captureResizeObserverExceededError);
        };
    }, []);
}
function fractionalItemSize(element) {
    return element.getBoundingClientRect().height;
}
function findMessageIndex(messages, id) {
    return messages.findIndex(function (message) { return message.id === id; });
}
function calculateInitialTopMostItemIndex(messages, highlightedMessageId) {
    if (highlightedMessageId) {
        var index = findMessageIndex(messages, highlightedMessageId);
        if (index !== -1) {
            return { align: 'center', index: index };
        }
    }
    return messages.length - 1;
}
var VirtualizedMessageListWithContext = function (props) {
    var _a, _b;
    var additionalMessageInputProps = props.additionalMessageInputProps, _c = props.additionalVirtuosoProps, additionalVirtuosoProps = _c === void 0 ? {} : _c, channel = props.channel, channelUnreadUiState = props.channelUnreadUiState, closeReactionSelectorOnClick = props.closeReactionSelectorOnClick, customMessageActions = props.customMessageActions, customMessageRenderer = props.customMessageRenderer, defaultItemHeight = props.defaultItemHeight, _d = props.disableDateSeparator, disableDateSeparator = _d === void 0 ? true : _d, groupStyles = props.groupStyles, hasMoreNewer = props.hasMoreNewer, head = props.head, _e = props.hideDeletedMessages, hideDeletedMessages = _e === void 0 ? false : _e, _f = props.hideNewMessageSeparator, hideNewMessageSeparator = _f === void 0 ? false : _f, highlightedMessageId = props.highlightedMessageId, jumpToLatestMessage = props.jumpToLatestMessage, loadingMore = props.loadingMore, loadMore = props.loadMore, loadMoreNewer = props.loadMoreNewer, MessageUIComponentFromProps = props.Message, messageActions = props.messageActions, _g = props.messageLimit, messageLimit = _g === void 0 ? Window.DEFAULT_NEXT_CHANNEL_PAGE_SIZE : _g, messages = props.messages, notifications = props.notifications, 
    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component
    _h = props.overscan, 
    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component
    overscan = _h === void 0 ? 0 : _h, read = props.read, _j = props.returnAllReadData, returnAllReadData = _j === void 0 ? false : _j, scrollSeekPlaceHolder = props.scrollSeekPlaceHolder, _k = props.scrollToLatestMessageOnFocus, scrollToLatestMessageOnFocus = _k === void 0 ? false : _k, _l = props.separateGiphyPreview, separateGiphyPreview = _l === void 0 ? false : _l, _m = props.shouldGroupByUser, shouldGroupByUser = _m === void 0 ? false : _m, showUnreadNotificationAlways = props.showUnreadNotificationAlways, sortReactionDetails = props.sortReactionDetails, sortReactions = props.sortReactions, _o = props.stickToBottomScrollBehavior, stickToBottomScrollBehavior = _o === void 0 ? 'smooth' : _o, suppressAutoscroll = props.suppressAutoscroll, threadList = props.threadList;
    var virtuosoComponentsFromProps = additionalVirtuosoProps.components, overridingVirtuosoProps = Window.__rest(additionalVirtuosoProps, ["components"]);
    // Stops errors generated from react-virtuoso to bubble up
    // to Sentry or other tracking tools.
    useCaptureResizeObserverExceededError();
    var _p = Window.useComponentContext('VirtualizedMessageList'), DateSeparator = _p.DateSeparator, _q = _p.GiphyPreviewMessage, GiphyPreviewMessage$1 = _q === void 0 ? GiphyPreviewMessage : _q, _r = _p.MessageListNotifications, MessageListNotifications$1 = _r === void 0 ? MessageListNotifications : _r, _s = _p.MessageNotification, MessageNotification = _s === void 0 ? Window.MessageNotification : _s, MessageSystem = _p.MessageSystem, _t = _p.UnreadMessagesNotification, UnreadMessagesNotification$1 = _t === void 0 ? UnreadMessagesNotification : _t, UnreadMessagesSeparator = _p.UnreadMessagesSeparator, _u = _p.VirtualMessage, MessageUIComponentFromContext = _u === void 0 ? Window.MessageSimple : _u;
    var MessageUIComponent = MessageUIComponentFromProps || MessageUIComponentFromContext;
    var _v = Window.useChatContext('VirtualizedMessageList'), client = _v.client, customClasses = _v.customClasses;
    var virtuoso = React.useRef(null);
    var lastRead = React.useMemo(function () { var _a; return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel); }, [channel]);
    var _w = useUnreadMessagesNotificationVirtualized({
        lastRead: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read,
        showAlways: !!showUnreadNotificationAlways,
        unreadCount: (_a = channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages) !== null && _a !== void 0 ? _a : 0,
    }), showUnreadMessagesNotification = _w.show, toggleShowUnreadMessagesNotification = _w.toggleShowUnreadMessagesNotification;
    var _x = useGiphyPreview(separateGiphyPreview), giphyPreviewMessage = _x.giphyPreviewMessage, setGiphyPreviewMessage = _x.setGiphyPreviewMessage;
    var processedMessages = React.useMemo(function () {
        if (typeof messages === 'undefined') {
            return [];
        }
        if (disableDateSeparator &&
            !hideDeletedMessages &&
            hideNewMessageSeparator &&
            !separateGiphyPreview) {
            return messages;
        }
        return Window.processMessages({
            enableDateSeparator: !disableDateSeparator,
            hideDeletedMessages: hideDeletedMessages,
            hideNewMessageSeparator: hideNewMessageSeparator,
            lastRead: lastRead,
            messages: messages,
            setGiphyPreviewMessage: setGiphyPreviewMessage,
            userId: client.userID || '',
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        disableDateSeparator,
        hideDeletedMessages,
        hideNewMessageSeparator,
        lastRead,
        messages,
        messages === null || messages === void 0 ? void 0 : messages.length,
        client.userID,
    ]);
    // get the mapping of own messages to array of users who read them
    var ownMessagesReadByOthers = useLastReadData({
        messages: processedMessages,
        read: read,
        returnAllReadData: returnAllReadData,
        userID: client.userID,
    });
    var lastReceivedMessageId = React.useMemo(function () { return Window.getLastReceived(processedMessages); }, [
        processedMessages,
    ]);
    var groupStylesFn = groupStyles || Window.getGroupStyles;
    var messageGroupStyles = React.useMemo(function () {
        return processedMessages.reduce(function (acc, message, i) {
            var style = groupStylesFn(message, processedMessages[i - 1], processedMessages[i + 1], !shouldGroupByUser);
            if (style)
                acc[message.id] = style;
            return acc;
        }, {});
    }, 
    // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [processedMessages.length, shouldGroupByUser, groupStylesFn]);
    var _y = useNewMessageNotification(processedMessages, client.userID, hasMoreNewer), atBottom = _y.atBottom, isMessageListScrolledToBottom = _y.isMessageListScrolledToBottom, newMessagesNotification = _y.newMessagesNotification, setIsMessageListScrolledToBottom = _y.setIsMessageListScrolledToBottom, setNewMessagesNotification = _y.setNewMessagesNotification;
    useMarkRead({
        isMessageListScrolledToBottom: isMessageListScrolledToBottom,
        messageListIsThread: !!threadList,
        unreadCount: (_b = channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages) !== null && _b !== void 0 ? _b : 0,
        wasMarkedUnread: !!(channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id),
    });
    var scrollToBottom = React.useCallback(function () { return Window.__awaiter(void 0, void 0, void 0, function () {
        return Window.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!hasMoreNewer) return [3 /*break*/, 2];
                    return [4 /*yield*/, jumpToLatestMessage()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
                case 2:
                    if (virtuoso.current) {
                        virtuoso.current.scrollToIndex(processedMessages.length - 1);
                    }
                    setNewMessagesNotification(false);
                    return [2 /*return*/];
            }
        });
    }); }, [
        virtuoso,
        processedMessages,
        setNewMessagesNotification,
        // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage
        processedMessages.length,
        hasMoreNewer,
        jumpToLatestMessage,
    ]);
    useScrollToBottomOnNewMessage({ messages: messages, scrollToBottom: scrollToBottom, scrollToLatestMessageOnFocus: scrollToLatestMessageOnFocus });
    var numItemsPrepended = usePrependedMessagesCount(processedMessages, !disableDateSeparator);
    var messageSetKey = useMessageSetKey({ messages: messages }).messageSetKey;
    var shouldForceScrollToBottom = useShouldForceScrollToBottom(processedMessages, client.userID);
    var handleItemsRendered = React.useMemo(function () { return makeItemsRenderedHandler([toggleShowUnreadMessagesNotification], processedMessages); }, [processedMessages, toggleShowUnreadMessagesNotification]);
    var followOutput = function (isAtBottom) {
        if (hasMoreNewer || suppressAutoscroll) {
            return false;
        }
        if (shouldForceScrollToBottom()) {
            return isAtBottom ? stickToBottomScrollBehavior : 'auto';
        }
        // a message from another user has been received - don't scroll to bottom unless already there
        return isAtBottom ? stickToBottomScrollBehavior : false;
    };
    var computeItemKey = React.useCallback(function (index, _, _a) {
        var numItemsPrepended = _a.numItemsPrepended, processedMessages = _a.processedMessages;
        return processedMessages[calculateItemIndex(index, numItemsPrepended)].id;
    }, []);
    var atBottomStateChange = function (isAtBottom) {
        atBottom.current = isAtBottom;
        setIsMessageListScrolledToBottom(isAtBottom);
        if (isAtBottom) {
            loadMoreNewer === null || loadMoreNewer === void 0 ? void 0 : loadMoreNewer(messageLimit);
            setNewMessagesNotification === null || setNewMessagesNotification === void 0 ? void 0 : setNewMessagesNotification(false);
        }
    };
    var atTopStateChange = function (isAtTop) {
        if (isAtTop) {
            loadMore === null || loadMore === void 0 ? void 0 : loadMore(messageLimit);
        }
    };
    React.useEffect(function () {
        var scrollTimeout;
        if (highlightedMessageId) {
            var index_1 = findMessageIndex(processedMessages, highlightedMessageId);
            if (index_1 !== -1) {
                scrollTimeout = setTimeout(function () {
                    var _a;
                    (_a = virtuoso.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({ align: 'center', index: index_1 });
                }, 0);
            }
        }
        return function () {
            clearTimeout(scrollTimeout);
        };
    }, [highlightedMessageId, processedMessages]);
    if (!processedMessages)
        return null;
    return (React__default["default"].createElement(React__default["default"].Fragment, null,
        React__default["default"].createElement(MessageListMainPanel, null,
            !threadList && showUnreadMessagesNotification && (React__default["default"].createElement(UnreadMessagesNotification$1, { unreadCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages })),
            React__default["default"].createElement("div", { className: (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualizedMessageList) || 'str-chat__virtual-list' },
                React__default["default"].createElement(reactVirtuoso.Virtuoso, Window.__assign({ atBottomStateChange: atBottomStateChange, atBottomThreshold: 100, atTopStateChange: atTopStateChange, atTopThreshold: 100, className: 'str-chat__message-list-scroll', components: Window.__assign({ EmptyPlaceholder: EmptyPlaceholder, Footer: Footer, Header: Header, Item: Item }, virtuosoComponentsFromProps), computeItemKey: computeItemKey, context: {
                        additionalMessageInputProps: additionalMessageInputProps,
                        closeReactionSelectorOnClick: closeReactionSelectorOnClick,
                        customClasses: customClasses,
                        customMessageActions: customMessageActions,
                        customMessageRenderer: customMessageRenderer,
                        DateSeparator: DateSeparator,
                        firstUnreadMessageId: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id,
                        head: head,
                        lastReadMessageId: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read_message_id,
                        lastReceivedMessageId: lastReceivedMessageId,
                        loadingMore: loadingMore,
                        Message: MessageUIComponent,
                        messageActions: messageActions,
                        messageGroupStyles: messageGroupStyles,
                        MessageSystem: MessageSystem,
                        numItemsPrepended: numItemsPrepended,
                        ownMessagesReadByOthers: ownMessagesReadByOthers,
                        processedMessages: processedMessages,
                        shouldGroupByUser: shouldGroupByUser,
                        sortReactionDetails: sortReactionDetails,
                        sortReactions: sortReactions,
                        threadList: threadList,
                        unreadMessageCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages,
                        UnreadMessagesSeparator: UnreadMessagesSeparator,
                        virtuosoRef: virtuoso,
                    }, firstItemIndex: calculateFirstItemIndex(numItemsPrepended), followOutput: followOutput, increaseViewportBy: { bottom: 200, top: 0 }, initialTopMostItemIndex: calculateInitialTopMostItemIndex(processedMessages, highlightedMessageId), itemContent: messageRenderer, itemSize: fractionalItemSize, itemsRendered: handleItemsRendered, key: messageSetKey, overscan: overscan, ref: virtuoso, style: { overflowX: 'hidden' }, totalCount: processedMessages.length }, overridingVirtuosoProps, (scrollSeekPlaceHolder ? { scrollSeek: scrollSeekPlaceHolder } : {}), (defaultItemHeight ? { defaultItemHeight: defaultItemHeight } : {}))))),
        React__default["default"].createElement(MessageListNotifications$1, { hasNewMessages: newMessagesNotification, isMessageListScrolledToBottom: isMessageListScrolledToBottom, isNotAtLatestMessageSet: hasMoreNewer, MessageNotification: MessageNotification, notifications: notifications, scrollToBottom: scrollToBottom, threadList: threadList, unreadCount: threadList ? undefined : channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages }),
        giphyPreviewMessage && React__default["default"].createElement(GiphyPreviewMessage$1, { message: giphyPreviewMessage })));
};
/**
 * The VirtualizedMessageList component renders a list of messages in a virtualized list.
 * It is a consumer of the React contexts set in [Channel](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Channel/Channel.tsx).
 */
function VirtualizedMessageList(props) {
    var _a = Window.useChannelActionContext('VirtualizedMessageList'), jumpToLatestMessage = _a.jumpToLatestMessage, loadMore = _a.loadMore, loadMoreNewer = _a.loadMoreNewer;
    var _b = Window.useChannelStateContext('VirtualizedMessageList'), channel = _b.channel, channelUnreadUiState = _b.channelUnreadUiState, hasMore = _b.hasMore, hasMoreNewer = _b.hasMoreNewer, highlightedMessageId = _b.highlightedMessageId, loadingMore = _b.loadingMore, loadingMoreNewer = _b.loadingMoreNewer, contextMessages = _b.messages, notifications = _b.notifications, read = _b.read, suppressAutoscroll = _b.suppressAutoscroll;
    var messages = props.messages || contextMessages;
    return (React__default["default"].createElement(VirtualizedMessageListWithContext, Window.__assign({ channel: channel, channelUnreadUiState: channelUnreadUiState, hasMore: !!hasMore, hasMoreNewer: !!hasMoreNewer, highlightedMessageId: highlightedMessageId, jumpToLatestMessage: jumpToLatestMessage, loadingMore: !!loadingMore, loadingMoreNewer: !!loadingMoreNewer, loadMore: loadMore, loadMoreNewer: loadMoreNewer, messages: messages, notifications: notifications, read: read, suppressAutoscroll: suppressAutoscroll }, props)));
}

var version = '11.11.0';

var useChat = function (_a) {
    var _b, _c;
    var client = _a.client, _d = _a.defaultLanguage, defaultLanguage = _d === void 0 ? 'en' : _d, i18nInstance = _a.i18nInstance, initialNavOpen = _a.initialNavOpen;
    var _e = React.useState({
        t: function (key) { return key; },
        tDateTimeParser: Window.defaultDateTimeParser,
        userLanguage: 'en',
    }), translators = _e[0], setTranslators = _e[1];
    var _f = React.useState(), channel = _f[0], setChannel = _f[1];
    var _g = React.useState([]), mutes = _g[0], setMutes = _g[1];
    var _h = React.useState(initialNavOpen), navOpen = _h[0], setNavOpen = _h[1];
    var _j = React.useState({}), latestMessageDatesByChannels = _j[0], setLatestMessageDatesByChannels = _j[1];
    var clientMutes = ((_b = client.user) === null || _b === void 0 ? void 0 : _b.mutes) || [];
    var closeMobileNav = function () { return setNavOpen(false); };
    var openMobileNav = function () { return setTimeout(function () { return setNavOpen(true); }, 100); };
    var appSettings = React.useRef(null);
    var getAppSettings = function () {
        if (appSettings.current) {
            return appSettings.current;
        }
        appSettings.current = client.getAppSettings();
        return appSettings.current;
    };
    React.useEffect(function () {
        if (client) {
            var userAgent = client.getUserAgent();
            if (!userAgent.includes('stream-chat-react')) {
                // result looks like: 'stream-chat-react-2.3.2-stream-chat-javascript-client-browser-2.2.2'
                client.setUserAgent("stream-chat-react-".concat(version, "-").concat(userAgent));
            }
        }
    }, [client]);
    React.useEffect(function () {
        setMutes(clientMutes);
        var handleEvent = function (event) {
            var _a;
            setMutes(((_a = event.me) === null || _a === void 0 ? void 0 : _a.mutes) || []);
        };
        client.on('notification.mutes_updated', handleEvent);
        return function () { return client.off('notification.mutes_updated', handleEvent); };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [clientMutes === null || clientMutes === void 0 ? void 0 : clientMutes.length]);
    React.useEffect(function () {
        var _a;
        var userLanguage = (_a = client.user) === null || _a === void 0 ? void 0 : _a.language;
        if (!userLanguage) {
            var browserLanguage = window.navigator.language.slice(0, 2); // just get language code, not country-specific version
            userLanguage = Window.isLanguageSupported(browserLanguage) ? browserLanguage : defaultLanguage;
        }
        var streami18n = i18nInstance || new Window.Streami18n({ language: userLanguage });
        streami18n.registerSetLanguageCallback(function (t) {
            return setTranslators(function (prevTranslator) { return (Window.__assign(Window.__assign({}, prevTranslator), { t: t })); });
        });
        streami18n.getTranslators().then(function (translator) {
            setTranslators(Window.__assign(Window.__assign({}, translator), { userLanguage: userLanguage || defaultLanguage }));
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [i18nInstance]);
    var setActiveChannel = React.useCallback(function (activeChannel, watchers, event) {
        if (watchers === void 0) { watchers = {}; }
        return Window.__awaiter(void 0, void 0, void 0, function () {
            return Window.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (event && event.preventDefault)
                            event.preventDefault();
                        if (!(activeChannel && Object.keys(watchers).length)) return [3 /*break*/, 2];
                        return [4 /*yield*/, activeChannel.query({ watch: true, watchers: watchers })];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        setChannel(activeChannel);
                        closeMobileNav();
                        return [2 /*return*/];
                }
            });
        });
    }, []);
    React.useEffect(function () {
        setLatestMessageDatesByChannels({});
    }, [(_c = client.user) === null || _c === void 0 ? void 0 : _c.id]);
    return {
        channel: channel,
        closeMobileNav: closeMobileNav,
        getAppSettings: getAppSettings,
        latestMessageDatesByChannels: latestMessageDatesByChannels,
        mutes: mutes,
        navOpen: navOpen,
        openMobileNav: openMobileNav,
        setActiveChannel: setActiveChannel,
        translators: translators,
    };
};

var useCreateChatContext = function (value) {
    var _a;
    var channel = value.channel, channelsQueryState = value.channelsQueryState, client = value.client, closeMobileNav = value.closeMobileNav, customClasses = value.customClasses, getAppSettings = value.getAppSettings, latestMessageDatesByChannels = value.latestMessageDatesByChannels, mutes = value.mutes, navOpen = value.navOpen, openMobileNav = value.openMobileNav, setActiveChannel = value.setActiveChannel, theme = value.theme, themeVersion = value.themeVersion, useImageFlagEmojisOnWindows = value.useImageFlagEmojisOnWindows;
    var channelCid = channel === null || channel === void 0 ? void 0 : channel.cid;
    var channelsQueryError = channelsQueryState.error;
    var channelsQueryInProgress = channelsQueryState.queryInProgress;
    var clientValues = "".concat(client.clientID).concat(Object.keys(client.activeChannels).length).concat(Object.keys(client.listeners).length).concat(client.mutedChannels.length, "\n  ").concat((_a = client.user) === null || _a === void 0 ? void 0 : _a.id);
    var mutedUsersLength = mutes.length;
    var chatContext = React.useMemo(function () { return ({
        channel: channel,
        channelsQueryState: channelsQueryState,
        client: client,
        closeMobileNav: closeMobileNav,
        customClasses: customClasses,
        getAppSettings: getAppSettings,
        latestMessageDatesByChannels: latestMessageDatesByChannels,
        mutes: mutes,
        navOpen: navOpen,
        openMobileNav: openMobileNav,
        setActiveChannel: setActiveChannel,
        theme: theme,
        themeVersion: themeVersion,
        useImageFlagEmojisOnWindows: useImageFlagEmojisOnWindows,
    }); }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        channelCid,
        channelsQueryError,
        channelsQueryInProgress,
        clientValues,
        getAppSettings,
        mutedUsersLength,
        navOpen,
    ]);
    return chatContext;
};

var useChannelsQueryState = function () {
    var _a = React.useState(null), error = _a[0], setError = _a[1];
    var _b = React.useState('uninitialized'), queryInProgress = _b[0], setQueryInProgress = _b[1];
    return {
        error: error,
        queryInProgress: queryInProgress,
        setError: setError,
        setQueryInProgress: setQueryInProgress,
    };
};

var darkModeTheme = {
    '--bg-gradient-end': '#101214',
    '--bg-gradient-start': '#070a0d',
    '--black': '#ffffff',
    '--blue-alice': '#00193d',
    '--border': '#141924',
    '--button-background': '#ffffff',
    '--button-text': '#005fff',
    '--grey': '#7a7a7a',
    '--grey-gainsboro': '#2d2f2f',
    '--grey-whisper': '#1c1e22',
    '--modal-shadow': '#000000',
    '--overlay': '#00000066',
    '--overlay-dark': '#ffffffcc',
    '--shadow-icon': '#00000080',
    '--targetedMessageBackground': '#302d22',
    '--transparent': 'transparent',
    '--white': '#101418',
    '--white-smoke': '#13151b',
    '--white-snow': '#070a0d',
};
/**
 * @deprecated This hook has been deprecated in favor of the new
 * theming (V2) setup which sets its variables through CSS files.
 * Refer to the [documentation](https://getstream.io/chat/docs/sdk/react/theming/themingv2/) of the new theming for the upgrade.
 *
 * **Will be removed with the complete transition to the theming V2.**
 */
var useCustomStyles = function (customStyles) {
    if (!customStyles)
        return;
    for (var _i = 0, _a = Object.entries(customStyles); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        document.documentElement.style.setProperty(key, value);
    }
};

/**
 * Wrapper component for a StreamChat application. Chat needs to be placed around any other chat components
 * as it provides the ChatContext.
 */
var Chat = function (props) {
    var children = props.children, client = props.client, customClasses = props.customClasses, customStyles = props.customStyles, _a = props.darkMode, darkMode = _a === void 0 ? false : _a, defaultLanguage = props.defaultLanguage, i18nInstance = props.i18nInstance, _b = props.initialNavOpen, initialNavOpen = _b === void 0 ? true : _b, _c = props.theme, theme = _c === void 0 ? 'messaging light' : _c, _d = props.useImageFlagEmojisOnWindows, useImageFlagEmojisOnWindows = _d === void 0 ? false : _d;
    var _e = useChat({ client: client, defaultLanguage: defaultLanguage, i18nInstance: i18nInstance, initialNavOpen: initialNavOpen }), channel = _e.channel, closeMobileNav = _e.closeMobileNav, getAppSettings = _e.getAppSettings, latestMessageDatesByChannels = _e.latestMessageDatesByChannels, mutes = _e.mutes, navOpen = _e.navOpen, openMobileNav = _e.openMobileNav, setActiveChannel = _e.setActiveChannel, translators = _e.translators;
    var channelsQueryState = useChannelsQueryState();
    var themeVersion = typeof window !== 'undefined'
        ? (window
            .getComputedStyle(document.documentElement)
            .getPropertyValue('--str-chat__theme-version')
            .replace(' ', '') || '1')
        : '1';
    useCustomStyles(darkMode ? darkModeTheme : customStyles);
    var chatContextValue = useCreateChatContext({
        channel: channel,
        channelsQueryState: channelsQueryState,
        client: client,
        closeMobileNav: closeMobileNav,
        customClasses: customClasses,
        getAppSettings: getAppSettings,
        latestMessageDatesByChannels: latestMessageDatesByChannels,
        mutes: mutes,
        navOpen: navOpen,
        openMobileNav: openMobileNav,
        setActiveChannel: setActiveChannel,
        theme: theme,
        themeVersion: themeVersion,
        useImageFlagEmojisOnWindows: useImageFlagEmojisOnWindows,
    });
    if (!translators.t)
        return null;
    return (React__default["default"].createElement(Window.ChatProvider, { value: chatContextValue },
        React__default["default"].createElement(Window.TranslationProvider, { value: translators }, children)));
};

/**
 * React hook to create, connect and return `StreamChat` client.
 */
var useCreateChatClient = function (_a) {
    var apiKey = _a.apiKey, tokenOrProvider = _a.tokenOrProvider, userData = _a.userData;
    var _b = React.useState(null), chatClient = _b[0], setChatClient = _b[1];
    var _c = React.useState(userData), cachedUserData = _c[0], setCachedUserData = _c[1];
    if (userData.id !== cachedUserData.id) {
        setCachedUserData(userData);
    }
    React.useEffect(function () {
        var client = new streamChat.StreamChat(apiKey);
        var didUserConnectInterrupt = false;
        var connectionPromise = client.connectUser(cachedUserData, tokenOrProvider).then(function () {
            if (!didUserConnectInterrupt)
                setChatClient(client);
        });
        return function () {
            didUserConnectInterrupt = true;
            setChatClient(null);
            connectionPromise
                .then(function () { return client.disconnectUser(); })
                .then(function () {
                console.log("Connection for user \"".concat(cachedUserData.id, "\" has been closed"));
            });
        };
    }, [apiKey, cachedUserData, tokenOrProvider]);
    return chatClient;
};

var CloseIcon = function (_a) {
    var title = _a.title;
    var t = Window.useTranslationContext('CloseIcon').t;
    return (React__default["default"].createElement("svg", { "data-testid": 'close-no-outline', fill: 'none', viewBox: '0 0 24 24', xmlns: 'http://www.w3.org/2000/svg' },
        React__default["default"].createElement("title", null, title !== null && title !== void 0 ? title : t('Close')),
        React__default["default"].createElement("path", { d: 'M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12L19 6.41Z', fill: 'black' })));
};

var ThreadHeader = function (props) {
    var closeThread = props.closeThread, overrideImage = props.overrideImage, overrideTitle = props.overrideTitle;
    var t = Window.useTranslationContext('ThreadHeader').t;
    var channel = Window.useChannelStateContext('').channel;
    var displayTitle = Window.useChannelPreviewInfo({
        channel: channel,
        overrideImage: overrideImage,
        overrideTitle: overrideTitle,
    }).displayTitle;
    return (React__default["default"].createElement("div", { className: 'str-chat__thread-header' },
        React__default["default"].createElement("div", { className: 'str-chat__thread-header-details' },
            React__default["default"].createElement("div", { className: 'str-chat__thread-header-title' }, t('Thread')),
            React__default["default"].createElement("div", { className: 'str-chat__thread-header-subtitle' }, displayTitle)),
        React__default["default"].createElement("button", { "aria-label": t('aria/Close thread'), className: 'str-chat__square-button str-chat__close-thread-button', "data-testid": 'close-button', onClick: closeThread },
            React__default["default"].createElement(CloseIcon, null))));
};

var ThreadStart = function () {
    var thread = Window.useChannelStateContext('ThreadStart').thread;
    var t = Window.useTranslationContext('ThreadStart').t;
    if (!(thread === null || thread === void 0 ? void 0 : thread.reply_count))
        return null;
    return (React__default["default"].createElement("div", { className: 'str-chat__thread-start' }, t('replyCount', { count: thread.reply_count })));
};

var ThreadHead = function (props) {
    var _a = Window.useComponentContext('ThreadHead').ThreadStart, ThreadStart$1 = _a === void 0 ? ThreadStart : _a;
    return (React__default["default"].createElement("div", { className: 'str-chat__parent-message-li' },
        React__default["default"].createElement(Window.Message, Window.__assign({ initialMessage: true, threadList: true }, props)),
        React__default["default"].createElement(ThreadStart$1, null)));
};

/**
 * The Thread component renders a parent Message with a list of replies
 */
var Thread = function (props) {
    var _a = Window.useChannelStateContext('Thread'), channel = _a.channel, channelConfig = _a.channelConfig, thread = _a.thread;
    if (!thread || (channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.replies) === false)
        return null;
    // The wrapper ensures a key variable is set and the component recreates on thread switch
    return React__default["default"].createElement(ThreadInner, Window.__assign({}, props, { key: "thread-".concat(thread.id, "-").concat(channel === null || channel === void 0 ? void 0 : channel.cid) }));
};
var ThreadInner = function (props) {
    var _a, _b;
    var additionalMessageInputProps = props.additionalMessageInputProps, additionalMessageListProps = props.additionalMessageListProps, additionalParentMessageProps = props.additionalParentMessageProps, additionalVirtualizedMessageListProps = props.additionalVirtualizedMessageListProps, _c = props.autoFocus, autoFocus = _c === void 0 ? true : _c, _d = props.enableDateSeparator, enableDateSeparator = _d === void 0 ? false : _d, _e = props.fullWidth, fullWidth = _e === void 0 ? false : _e, PropInput = props.Input, PropMessage = props.Message, _f = props.messageActions, messageActions = _f === void 0 ? Object.keys(Window.MESSAGE_ACTIONS) : _f, virtualized = props.virtualized;
    var _g = Window.useChannelStateContext('Thread'), thread = _g.thread, threadHasMore = _g.threadHasMore, threadLoadingMore = _g.threadLoadingMore, threadMessages = _g.threadMessages, threadSuppressAutoscroll = _g.threadSuppressAutoscroll;
    var _h = Window.useChannelActionContext('Thread'), closeThread = _h.closeThread, loadMoreThread = _h.loadMoreThread;
    var _j = Window.useChatContext('Thread'), customClasses = _j.customClasses, themeVersion = _j.themeVersion;
    var _k = Window.useComponentContext('Thread'), ContextInput = _k.ThreadInput, ContextMessage = _k.Message, _l = _k.ThreadHead, ThreadHead$1 = _l === void 0 ? ThreadHead : _l, _m = _k.ThreadHeader, ThreadHeader$1 = _m === void 0 ? ThreadHeader : _m, VirtualMessage = _k.VirtualMessage;
    var ThreadInput = (_b = (_a = PropInput !== null && PropInput !== void 0 ? PropInput : additionalMessageInputProps === null || additionalMessageInputProps === void 0 ? void 0 : additionalMessageInputProps.Input) !== null && _a !== void 0 ? _a : ContextInput) !== null && _b !== void 0 ? _b : (themeVersion === '2' ? Window.MessageInputFlat : MessageInputSmall);
    var ThreadMessage = PropMessage || (additionalMessageListProps === null || additionalMessageListProps === void 0 ? void 0 : additionalMessageListProps.Message);
    var FallbackMessage = virtualized && VirtualMessage ? VirtualMessage : ContextMessage;
    var MessageUIComponent = ThreadMessage || FallbackMessage;
    var ThreadMessageList = virtualized ? VirtualizedMessageList : MessageList;
    React.useEffect(function () {
        if ((thread === null || thread === void 0 ? void 0 : thread.id) && (thread === null || thread === void 0 ? void 0 : thread.reply_count)) {
            // FIXME: integrators can customize channel query options but cannot customize channel.getReplies() options
            loadMoreThread();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    if (!thread)
        return null;
    var threadClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.thread) ||
        Window.clsx('str-chat__thread-container str-chat__thread', {
            'str-chat__thread--full': fullWidth,
            'str-chat__thread--virtualized': virtualized,
        });
    var head = (React__default["default"].createElement(ThreadHead$1, Window.__assign({ key: thread.id, message: thread, Message: MessageUIComponent }, additionalParentMessageProps)));
    return (React__default["default"].createElement("div", { className: threadClass },
        React__default["default"].createElement(ThreadHeader$1, { closeThread: closeThread, thread: thread }),
        React__default["default"].createElement(ThreadMessageList, Window.__assign({ disableDateSeparator: !enableDateSeparator, hasMore: threadHasMore, head: head, loadingMore: threadLoadingMore, loadMore: loadMoreThread, Message: MessageUIComponent, messageActions: messageActions, messages: threadMessages || [], suppressAutoscroll: threadSuppressAutoscroll, threadList: true }, (virtualized ? additionalVirtualizedMessageListProps : additionalMessageListProps))),
        React__default["default"].createElement(Window.MessageInput, Window.__assign({ focus: autoFocus, Input: ThreadInput, parent: thread, publishTypingEvent: false }, additionalMessageInputProps))));
};

exports.ACTIONS_NOT_WORKING_IN_THREAD = Window.ACTIONS_NOT_WORKING_IN_THREAD;
exports.ATTACHMENT_GROUPS_ORDER = Window.ATTACHMENT_GROUPS_ORDER;
exports.ActionsIcon = Window.ActionsIcon;
exports.Attachment = Window.Attachment;
exports.AttachmentActions = Window.AttachmentActions;
exports.AttachmentActionsContainer = Window.AttachmentActionsContainer;
exports.AttachmentPreviewList = Window.AttachmentPreviewList;
exports.AttachmentWithinContainer = Window.AttachmentWithinContainer;
exports.Audio = Window.Audio;
exports.AudioContainer = Window.AudioContainer;
exports.AutoCompleteTextarea = Window.ReactTextareaAutocomplete;
exports.Avatar = Window.Avatar;
exports.BaseImage = Window.BaseImage;
exports.Card = Window.Card;
exports.CardAudio = Window.CardAudio;
exports.CardContainer = Window.CardContainer;
exports.Channel = Window.Channel;
exports.ChannelActionContext = Window.ChannelActionContext;
exports.ChannelActionProvider = Window.ChannelActionProvider;
exports.ChannelHeader = Window.ChannelHeader;
exports.ChannelList = Window.ChannelList;
exports.ChannelListContext = Window.ChannelListContext;
exports.ChannelListContextProvider = Window.ChannelListContextProvider;
exports.ChannelListMessenger = Window.ChannelListMessenger;
exports.ChannelPreview = Window.ChannelPreview;
exports.ChannelPreviewMessenger = Window.ChannelPreviewMessenger;
exports.ChannelSearch = Window.ChannelSearch;
exports.ChannelStateContext = Window.ChannelStateContext;
exports.ChannelStateProvider = Window.ChannelStateProvider;
exports.ChatAutoComplete = Window.ChatAutoComplete;
exports.ChatContext = Window.ChatContext;
exports.ChatDown = Window.ChatDown;
exports.ChatProvider = Window.ChatProvider;
exports.CloseIcon = Window.CloseIcon$1;
exports.CommandItem = Window.CommandItem;
exports.ComponentContext = Window.ComponentContext;
exports.ComponentProvider = Window.ComponentProvider;
exports.ConnectionStatus = Window.ConnectionStatus;
exports.CooldownTimer = Window.CooldownTimer;
exports.CustomMessageActionsList = Window.CustomMessageActionsList;
exports.DateSeparator = Window.DateSeparator;
exports.DefaultSuggestionList = Window.List;
exports.DefaultSuggestionListHeader = Window.DefaultSuggestionListHeader;
exports.DefaultSuggestionListItem = Window.Item;
exports.DefaultTriggerProvider = Window.DefaultTriggerProvider;
exports.DeliveredCheckIcon = Window.DeliveredCheckIcon;
exports.DownloadIcon = Window.DownloadIcon;
exports.EditMessageForm = Window.EditMessageForm;
exports.EmojiIconLarge = Window.EmojiIconLarge;
exports.EmojiIconSmall = Window.EmojiIconSmall;
exports.EmojiPickerIcon = Window.EmojiPickerIcon;
exports.EmoticonItem = Window.EmoticonItem;
exports.EmptyStateIndicator = Window.EmptyStateIndicator;
exports.ErrorIcon = Window.ErrorIcon;
exports.EventComponent = Window.EventComponent;
exports.FileAttachment = Window.FileAttachment;
exports.FileContainer = Window.FileContainer;
exports.FileUploadIcon = Window.FileUploadIcon;
exports.FileUploadIconFlat = Window.FileUploadIconFlat;
exports.FixedHeightMessage = Window.FixedHeightMessage;
exports.Gallery = Window.Gallery;
exports.GalleryContainer = Window.GalleryContainer;
exports.ImageComponent = Window.ImageComponent;
exports.ImageContainer = Window.ImageContainer;
exports.LinkIcon = Window.LinkIcon;
exports.LinkPreviewList = Window.LinkPreviewList;
Object.defineProperty(exports, 'LinkPreviewState', {
    enumerable: true,
    get: function () { return Window.LinkPreviewState; }
});
exports.LoadMoreButton = Window.LoadMoreButton;
exports.LoadMorePaginator = Window.LoadMorePaginator;
exports.LoadingChannels = Window.LoadingChannels;
exports.LoadingErrorIndicator = Window.LoadingErrorIndicator;
exports.LoadingIndicator = Window.LoadingIndicator;
exports.LoadingIndicatorIcon = Window.LoadingIndicatorIcon;
exports.MAX_MESSAGE_REACTIONS_TO_FETCH = Window.MAX_MESSAGE_REACTIONS_TO_FETCH;
exports.MAX_QUERY_CHANNELS_LIMIT = Window.MAX_QUERY_CHANNELS_LIMIT;
exports.MESSAGE_ACTIONS = Window.MESSAGE_ACTIONS;
exports.MML = Window.MML;
exports.MediaContainer = Window.MediaContainer;
exports.Message = Window.Message;
exports.MessageActions = Window.MessageActions;
exports.MessageActionsBox = Window.MessageActionsBox;
exports.MessageBounceProvider = Window.MessageBounceProvider;
exports.MessageContext = Window.MessageContext;
exports.MessageDeleted = Window.MessageDeleted;
exports.MessageDeliveredIcon = Window.MessageDeliveredIcon;
Object.defineProperty(exports, 'MessageDeliveryStatus', {
    enumerable: true,
    get: function () { return Window.MessageDeliveryStatus; }
});
exports.MessageErrorIcon = Window.MessageErrorIcon;
exports.MessageInput = Window.MessageInput;
exports.MessageInputContext = Window.MessageInputContext;
exports.MessageInputContextProvider = Window.MessageInputContextProvider;
exports.MessageInputFlat = Window.MessageInputFlat;
exports.MessageListContext = Window.MessageListContext;
exports.MessageListContextProvider = Window.MessageListContextProvider;
exports.MessageNotification = Window.MessageNotification;
exports.MessageOptions = Window.MessageOptions;
exports.MessageProvider = Window.MessageProvider;
exports.MessageRepliesCountButton = Window.MessageRepliesCountButton;
exports.MessageSimple = Window.MessageSimple;
exports.MessageStatus = Window.MessageStatus;
exports.MessageText = Window.MessageText;
exports.MessageTimestamp = Window.MessageTimestamp;
exports.Modal = Window.Modal;
exports.ModalGallery = Window.ModalGallery;
exports.NullComponent = Window.NullComponent;
exports.PinIcon = Window.PinIcon;
exports.PinIndicator = Window.PinIndicator;
exports.PlayButton = Window.PlayButton;
exports.PopperTooltip = Window.PopperTooltip;
exports.ProgressBar = Window.ProgressBar;
exports.QuotedMessage = Window.QuotedMessage;
exports.QuotedMessagePreview = Window.QuotedMessagePreview;
exports.QuotedMessagePreviewHeader = Window.QuotedMessagePreviewHeader;
exports.ReactionIcon = Window.ReactionIcon;
exports.ReactionSelector = Window.ReactionSelector;
exports.ReactionsList = Window.ReactionsList;
exports.ReplyIcon = Window.ReplyIcon;
exports.RetryIcon = Window.RetryIcon;
exports.SUPPORTED_VIDEO_FORMATS = Window.SUPPORTED_VIDEO_FORMATS;
exports.SafeAnchor = Window.SafeAnchor;
exports.ScrollToBottomButton = Window.ScrollToBottomButton;
exports.SearchBar = Window.SearchBar;
exports.SearchInput = Window.SearchInput;
exports.SearchResults = Window.SearchResults;
exports.SendButton = Window.SendButton;
exports.SendIconV1 = Window.SendIconV1;
exports.SendIconV2 = Window.SendIconV2;
Object.defineProperty(exports, 'SetLinkPreviewMode', {
    enumerable: true,
    get: function () { return Window.SetLinkPreviewMode; }
});
exports.SimpleReactionsList = Window.SimpleReactionsList;
exports.SpriteImage = Window.SpriteImage;
exports.StreamEmoji = Window.StreamEmoji;
exports.Streami18n = Window.Streami18n;
exports.ThreadIcon = Window.ThreadIcon;
exports.Tooltip = Window.Tooltip;
exports.TranslationContext = Window.TranslationContext;
exports.TranslationProvider = Window.TranslationProvider;
exports.TypingContext = Window.TypingContext;
exports.TypingIndicator = Window.TypingIndicator;
exports.TypingProvider = Window.TypingProvider;
exports.UNREAD_MESSAGE_SEPARATOR_CLASS = Window.UNREAD_MESSAGE_SEPARATOR_CLASS;
exports.UnMemoizedLoadMorePaginator = Window.UnMemoizedLoadMorePaginator;
exports.UnreadMessagesSeparator = Window.UnreadMessagesSeparator;
exports.UnsupportedAttachment = Window.UnsupportedAttachment;
exports.UnsupportedAttachmentContainer = Window.UnsupportedAttachmentContainer;
exports.UploadButton = Window.UploadButton;
exports.UploadIcon = Window.UploadIcon;
exports.UploadsPreview = Window.UploadsPreview;
exports.UserItem = Window.UserItem;
exports.Window = Window.Window;
exports.areMessagePropsEqual = Window.areMessagePropsEqual;
exports.areMessageUIPropsEqual = Window.areMessageUIPropsEqual;
exports.deTranslations = Window.deTranslations;
exports.defaultAllowedTagNames = Window.defaultAllowedTagNames;
exports.defaultDateTimeParser = Window.defaultDateTimeParser;
exports.defaultPinPermissions = Window.defaultPinPermissions;
exports.defaultReactionOptions = Window.defaultReactionOptions;
exports.defaultScrollToItem = Window.defaultScrollToItem;
exports.defaultTimestampFormat = Window.defaultTimestampFormat;
exports.defaultTranslatorFunction = Window.defaultTranslatorFunction;
exports.emojiMarkdownPlugin = Window.emojiMarkdownPlugin;
exports.enTranslations = Window.enTranslations;
exports.esTranslations = Window.esTranslations;
exports.escapeRegExp = Window.escapeRegExp;
exports.frTranslations = Window.frTranslations;
exports.generateRandomId = Window.generateRandomId;
exports.getChannel = Window.getChannel;
exports.getDisplayImage = Window.getDisplayImage;
exports.getDisplayTitle = Window.getDisplayTitle;
exports.getGroupStyles = Window.getGroupStyles;
exports.getImages = Window.getImages;
exports.getLastReceived = Window.getLastReceived;
exports.getLatestMessagePreview = Window.getLatestMessagePreview;
exports.getMessageActions = Window.getMessageActions;
exports.getNonImageAttachments = Window.getNonImageAttachments;
exports.getReadByTooltipText = Window.getReadByTooltipText;
exports.getReadStates = Window.getReadStates;
exports.getWholeChar = Window.getWholeChar;
exports.handleActionWarning = Window.handleActionWarning;
exports.hasMoreMessagesProbably = Window.hasMoreMessagesProbably;
exports.hasNotMoreMessages = Window.hasNotMoreMessages;
exports.hiTranslations = Window.hiTranslations;
exports.htmlToTextPlugin = Window.htmlToTextPlugin;
exports.insertIntro = Window.insertIntro;
exports.isAudioAttachment = Window.isAudioAttachment;
exports.isChannel = Window.isChannel;
exports.isDate = Window.isDate;
exports.isDayOrMoment = Window.isDayOrMoment;
exports.isFileAttachment = Window.isFileAttachment;
exports.isGalleryAttachmentType = Window.isGalleryAttachmentType;
exports.isLanguageSupported = Window.isLanguageSupported;
exports.isMediaAttachment = Window.isMediaAttachment;
exports.isMessageBounced = Window.isMessageBounced;
exports.isNumberOrString = Window.isNumberOrString;
exports.isOnlyEmojis = Window.isOnlyEmojis;
exports.isScrapedContent = Window.isScrapedContent;
exports.isSvgAttachment = Window.isSvgAttachment;
exports.isUploadedImage = Window.isUploadedImage;
exports.isUserMuted = Window.isUserMuted;
exports.itTranslations = Window.itTranslations;
exports.jaTranslations = Window.jaTranslations;
exports.keepLineBreaksPlugin = Window.keepLineBreaksPlugin;
exports.koTranslations = Window.koTranslations;
exports.makeDateMessageId = Window.makeDateMessageId;
exports.mapToUserNameOrId = Window.mapToUserNameOrId;
exports.markDownRenderers = Window.markDownRenderers;
exports.matchMarkdownLinks = Window.matchMarkdownLinks;
exports.mentionsMarkdownPlugin = Window.mentionsMarkdownPlugin;
exports.messageCodeBlocks = Window.messageCodeBlocks;
exports.messageHasAttachments = Window.messageHasAttachments;
exports.messageHasReactions = Window.messageHasReactions;
exports.missingUseFlagHandlerParameterWarning = Window.missingUseFlagHandlerParameterWarning;
exports.missingUseMuteHandlerParamsWarning = Window.missingUseMuteHandlerParamsWarning;
exports.moveChannelUp = Window.moveChannelUp;
exports.nlTranslations = Window.nlTranslations;
exports.processMessages = Window.processMessages;
exports.ptTranslations = Window.ptTranslations;
exports.reactionHandlerWarning = Window.reactionHandlerWarning;
exports.renderAttachmentActions = Window.renderAttachmentActions;
exports.renderAttachmentWithinContainer = Window.renderAttachmentWithinContainer;
exports.renderAudio = Window.renderAudio;
exports.renderCard = Window.renderCard;
exports.renderFile = Window.renderFile;
exports.renderGallery = Window.renderGallery;
exports.renderImage = Window.renderImage;
exports.renderMedia = Window.renderMedia;
exports.renderPreviewText = Window.renderPreviewText;
exports.renderText = Window.renderText;
exports.ruTranslations = Window.ruTranslations;
exports.showMessageActionsBox = Window.showMessageActionsBox;
exports.trTranslations = Window.trTranslations;
exports.useActionHandler = Window.useActionHandler;
exports.useChannelActionContext = Window.useChannelActionContext;
exports.useChannelDeletedListener = Window.useChannelDeletedListener;
exports.useChannelEditMessageHandler = Window.useEditMessageHandler;
exports.useChannelHiddenListener = Window.useChannelHiddenListener;
exports.useChannelListContext = Window.useChannelListContext;
exports.useChannelMentionsHandler = Window.useMentionsHandlers;
exports.useChannelPreviewInfo = Window.useChannelPreviewInfo;
exports.useChannelStateContext = Window.useChannelStateContext;
exports.useChannelTruncatedListener = Window.useChannelTruncatedListener;
exports.useChannelUpdatedListener = Window.useChannelUpdatedListener;
exports.useChannelVisibleListener = Window.useChannelVisibleListener;
exports.useChatContext = Window.useChatContext;
exports.useComponentContext = Window.useComponentContext;
exports.useConnectionRecoveredListener = Window.useConnectionRecoveredListener;
exports.useCooldownTimer = Window.useCooldownTimer;
exports.useDeleteHandler = Window.useDeleteHandler;
exports.useEditHandler = Window.useEditHandler;
exports.useFlagHandler = Window.useFlagHandler;
exports.useMarkUnreadHandler = Window.useMarkUnreadHandler;
exports.useMentionsHandler = Window.useMentionsHandler;
exports.useMessageBounceContext = Window.useMessageBounceContext;
exports.useMessageContext = Window.useMessageContext;
exports.useMessageInputContext = Window.useMessageInputContext;
exports.useMessageInputState = Window.useMessageInputState;
exports.useMessageListContext = Window.useMessageListContext;
exports.useMessageNewListener = Window.useMessageNewListener;
exports.useMobileNavigation = Window.useMobileNavigation;
exports.useMuteHandler = Window.useMuteHandler;
exports.useNotificationAddedToChannelListener = Window.useNotificationAddedToChannelListener;
exports.useNotificationMessageNewListener = Window.useNotificationMessageNewListener;
exports.useNotificationRemovedFromChannelListener = Window.useNotificationRemovedFromChannelListener;
exports.useOpenThreadHandler = Window.useOpenThreadHandler;
exports.usePaginatedChannels = Window.usePaginatedChannels;
exports.usePinHandler = Window.usePinHandler;
exports.useReactionClick = Window.useReactionClick;
exports.useReactionHandler = Window.useReactionHandler;
exports.useReactionsFetcher = Window.useReactionsFetcher;
exports.useRetryHandler = Window.useRetryHandler;
exports.useTranslationContext = Window.useTranslationContext;
exports.useTypingContext = Window.useTypingContext;
exports.useUserHandler = Window.useUserHandler;
exports.useUserPresenceChangedListener = Window.useUserPresenceChangedListener;
exports.useUserRole = Window.useUserRole;
exports.validateAndGetMessage = Window.validateAndGetMessage;
exports.withChannelActionContext = Window.withChannelActionContext;
exports.withChannelStateContext = Window.withChannelStateContext;
exports.withChatContext = Window.withChatContext;
exports.withComponentContext = Window.withComponentContext;
exports.withMessageContext = Window.withMessageContext;
exports.withTranslationContext = Window.withTranslationContext;
exports.withTypingContext = Window.withTypingContext;
exports.Chat = Chat;
exports.GiphyPreviewMessage = GiphyPreviewMessage;
exports.InfiniteScroll = InfiniteScroll;
exports.MessageInputSmall = MessageInputSmall;
exports.MessageList = MessageList;
exports.MessageListNotifications = MessageListNotifications;
exports.Thread = Thread;
exports.ThreadHeader = ThreadHeader;
exports.ThreadStart = ThreadStart;
exports.UnreadMessagesNotification = UnreadMessagesNotification;
exports.VirtualizedMessageList = VirtualizedMessageList;
exports.darkModeTheme = darkModeTheme;
exports.defaultRenderMessages = defaultRenderMessages;
exports.useChat = useChat;
exports.useCreateChatClient = useCreateChatClient;
exports.useCustomStyles = useCustomStyles;
exports.useEnrichedMessages = useEnrichedMessages;
exports.useLastReadData = useLastReadData;
exports.useMessageListElements = useMessageListElements;
exports.useMessageListScrollManager = useMessageListScrollManager;
exports.useNewMessageNotification = useNewMessageNotification;
exports.usePrependedMessagesCount = usePrependedMessagesCount;
exports.useScrollLocationLogic = useScrollLocationLogic;
exports.useShouldForceScrollToBottom = useShouldForceScrollToBottom;
