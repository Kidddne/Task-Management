import { __assign, __awaiter, __generator } from "tslib";
/* eslint-disable typescript-sort-keys/interface */
import React, { useEffect, useState } from 'react';
import { usePopper } from 'react-popper';
import Picker from '@emoji-mart/react';
import { useChatContext, useMessageInputContext, useTranslationContext, } from '../../context';
import { EmojiIconLarge, EmojiPickerIcon } from '../MessageInput/icons';
import { Tooltip } from '../Tooltip';
var classNames = {
    1: {
        buttonClassName: 'str-chat__input-flat-emojiselect',
        pickerContainerClassName: undefined,
        wrapperClassName: 'str-chat__emojiselect-wrapper',
    },
    2: {
        buttonClassName: 'str-chat__emoji-picker-button',
        pickerContainerClassName: 'str-chat__message-textarea-emoji-picker-container',
        wrapperClassName: 'str-chat__message-textarea-emoji-picker',
    },
};
export var EmojiPicker = function (props) {
    var _a, _b, _c;
    var themeVersion = useChatContext('EmojiPicker').themeVersion;
    var t = useTranslationContext('EmojiPicker').t;
    var _d = useMessageInputContext('EmojiPicker'), insertText = _d.insertText, textareaRef = _d.textareaRef;
    var _e = useState(false), displayPicker = _e[0], setDisplayPicker = _e[1];
    var _f = useState(null), referenceElement = _f[0], setReferenceElement = _f[1];
    var _g = useState(null), popperElement = _g[0], setPopperElement = _g[1];
    var _h = usePopper(referenceElement, popperElement, __assign({ placement: themeVersion === '2' ? 'top-end' : 'top-start' }, props.popperOptions)), attributes = _h.attributes, styles = _h.styles;
    var _j = classNames[themeVersion], buttonClassName = _j.buttonClassName, pickerContainerClassName = _j.pickerContainerClassName, wrapperClassName = _j.wrapperClassName;
    var _k = props.ButtonIconComponent, ButtonIconComponent = _k === void 0 ? themeVersion === '2' ? EmojiPickerIcon : EmojiIconLarge : _k;
    useEffect(function () {
        if (!popperElement || !referenceElement)
            return;
        var handlePointerDown = function (e) {
            var target = e.target;
            if (popperElement.contains(target) || referenceElement.contains(target))
                return;
            setDisplayPicker(false);
        };
        window.addEventListener('pointerdown', handlePointerDown);
        return function () { return window.removeEventListener('pointerdown', handlePointerDown); };
    }, [referenceElement, popperElement]);
    return (React.createElement("div", { className: (_a = props.wrapperClassName) !== null && _a !== void 0 ? _a : wrapperClassName },
        displayPicker && (React.createElement("div", __assign({ className: (_b = props.pickerContainerClassName) !== null && _b !== void 0 ? _b : pickerContainerClassName, style: styles.popper }, attributes.popper, { ref: setPopperElement }),
            React.createElement(Picker, __assign({ data: function () { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, import('@emoji-mart/data')];
                        case 1: return [2 /*return*/, (_a.sent()).default];
                    }
                }); }); }, onEmojiSelect: function (e) {
                    var _a;
                    insertText(e.native);
                    (_a = textareaRef.current) === null || _a === void 0 ? void 0 : _a.focus();
                } }, props.pickerProps)))),
        themeVersion === '1' && (React.createElement(Tooltip, null, displayPicker ? t('Close emoji picker') : t('Open emoji picker'))),
        React.createElement("button", { "aria-expanded": displayPicker, "aria-label": t('aria/Emoji picker'), className: (_c = props.buttonClassName) !== null && _c !== void 0 ? _c : buttonClassName, onClick: function () { return setDisplayPicker(function (cv) { return !cv; }); }, ref: setReferenceElement, type: 'button' }, ButtonIconComponent && React.createElement(ButtonIconComponent, null))));
};
