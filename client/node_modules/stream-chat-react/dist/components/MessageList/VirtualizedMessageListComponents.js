import { __assign, __rest } from "tslib";
import clsx from 'clsx';
import throttle from 'lodash.throttle';
import React from 'react';
import { EmptyStateIndicator as DefaultEmptyStateIndicator } from '../EmptyStateIndicator';
import { LoadingIndicator as DefaultLoadingIndicator } from '../Loading';
import { Message } from '../Message';
import { isDate, useComponentContext } from '../../context';
import { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';
var PREPEND_OFFSET = Math.pow(10, 7);
export function calculateItemIndex(virtuosoIndex, numItemsPrepended) {
    return virtuosoIndex + numItemsPrepended - PREPEND_OFFSET;
}
export function calculateFirstItemIndex(numItemsPrepended) {
    return PREPEND_OFFSET - numItemsPrepended;
}
export var makeItemsRenderedHandler = function (renderedItemsActions, processedMessages) {
    return throttle(function (items) {
        var renderedMessages = items
            .map(function (item) {
            if (!item.originalIndex)
                return undefined;
            return processedMessages[calculateItemIndex(item.originalIndex, PREPEND_OFFSET)];
        })
            .filter(function (msg) { return !!msg; });
        renderedItemsActions.forEach(function (action) {
            return action(renderedMessages);
        });
    }, 200);
};
// using 'display: inline-block'
// traps CSS margins of the item elements, preventing incorrect item measurements
export var Item = function (_a) {
    var _b;
    var _c;
    var context = _a.context, props = __rest(_a, ["context"]);
    if (!context)
        return React.createElement(React.Fragment, null);
    var message = context.processedMessages[calculateItemIndex(props['data-item-index'], context.numItemsPrepended)];
    var groupStyles = context.messageGroupStyles[message.id];
    return (React.createElement("div", __assign({}, props, { className: ((_c = context === null || context === void 0 ? void 0 : context.customClasses) === null || _c === void 0 ? void 0 : _c.virtualMessage) ||
            clsx('str-chat__virtual-list-message-wrapper str-chat__li', (_b = {},
                _b["str-chat__li--".concat(groupStyles)] = groupStyles,
                _b)) })));
};
export var Header = function (_a) {
    var context = _a.context;
    var _b = useComponentContext('VirtualizedMessageListHeader').LoadingIndicator, LoadingIndicator = _b === void 0 ? DefaultLoadingIndicator : _b;
    if (!(context === null || context === void 0 ? void 0 : context.loadingMore))
        return null;
    return LoadingIndicator ? (React.createElement("div", { className: 'str-chat__virtual-list__loading' },
        React.createElement(LoadingIndicator, { size: 20 }))) : ((context === null || context === void 0 ? void 0 : context.head) || null);
};
export var EmptyPlaceholder = function (_a) {
    var context = _a.context;
    var _b = useComponentContext('VirtualizedMessageList').EmptyStateIndicator, EmptyStateIndicator = _b === void 0 ? DefaultEmptyStateIndicator : _b;
    return (React.createElement(React.Fragment, null, EmptyStateIndicator && (React.createElement(EmptyStateIndicator, { listType: (context === null || context === void 0 ? void 0 : context.threadList) ? 'thread' : 'message' }))));
};
export var Footer = function () {
    var TypingIndicator = useComponentContext('VirtualizedMessageList').TypingIndicator;
    return TypingIndicator ? React.createElement(TypingIndicator, { avatarSize: 24 }) : null;
};
export var messageRenderer = function (virtuosoIndex, _data, virtuosoContext) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var additionalMessageInputProps = virtuosoContext.additionalMessageInputProps, closeReactionSelectorOnClick = virtuosoContext.closeReactionSelectorOnClick, customMessageActions = virtuosoContext.customMessageActions, customMessageRenderer = virtuosoContext.customMessageRenderer, DateSeparator = virtuosoContext.DateSeparator, firstUnreadMessageId = virtuosoContext.firstUnreadMessageId, lastReadMessageId = virtuosoContext.lastReadMessageId, lastReceivedMessageId = virtuosoContext.lastReceivedMessageId, MessageUIComponent = virtuosoContext.Message, messageActions = virtuosoContext.messageActions, MessageSystem = virtuosoContext.MessageSystem, numItemsPrepended = virtuosoContext.numItemsPrepended, ownMessagesReadByOthers = virtuosoContext.ownMessagesReadByOthers, messageList = virtuosoContext.processedMessages, shouldGroupByUser = virtuosoContext.shouldGroupByUser, sortReactionDetails = virtuosoContext.sortReactionDetails, sortReactions = virtuosoContext.sortReactions, _k = virtuosoContext.unreadMessageCount, unreadMessageCount = _k === void 0 ? 0 : _k, UnreadMessagesSeparator = virtuosoContext.UnreadMessagesSeparator, virtuosoRef = virtuosoContext.virtuosoRef;
    var streamMessageIndex = calculateItemIndex(virtuosoIndex, numItemsPrepended);
    if (customMessageRenderer) {
        return customMessageRenderer(messageList, streamMessageIndex);
    }
    var message = messageList[streamMessageIndex];
    if (!message)
        return React.createElement("div", { style: { height: '1px' } }); // returning null or zero height breaks the virtuoso
    if (message.customType === CUSTOM_MESSAGE_TYPE.date && message.date && isDate(message.date)) {
        return DateSeparator ? React.createElement(DateSeparator, { date: message.date, unread: message.unread }) : null;
    }
    if (message.type === 'system') {
        return MessageSystem ? React.createElement(MessageSystem, { message: message }) : null;
    }
    var groupedByUser = shouldGroupByUser &&
        streamMessageIndex > 0 &&
        ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = messageList[streamMessageIndex - 1].user) === null || _b === void 0 ? void 0 : _b.id);
    var firstOfGroup = shouldGroupByUser && ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_e = (_d = messageList[streamMessageIndex - 1]) === null || _d === void 0 ? void 0 : _d.user) === null || _e === void 0 ? void 0 : _e.id);
    var endOfGroup = shouldGroupByUser && ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_h = (_g = messageList[streamMessageIndex + 1]) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.id);
    var isNewestMessage = lastReadMessageId === lastReceivedMessageId;
    var isLastReadMessage = message.id === lastReadMessageId;
    var showUnreadSeparator = isLastReadMessage && !isNewestMessage && (firstUnreadMessageId || unreadMessageCount > 0); // unread count can be 0 if the user marks unread only own messages
    return (React.createElement(React.Fragment, null,
        React.createElement(Message, { additionalMessageInputProps: additionalMessageInputProps, autoscrollToBottom: (_j = virtuosoRef.current) === null || _j === void 0 ? void 0 : _j.autoscrollToBottom, closeReactionSelectorOnClick: closeReactionSelectorOnClick, customMessageActions: customMessageActions, endOfGroup: endOfGroup, firstOfGroup: firstOfGroup, groupedByUser: groupedByUser, lastReceivedId: lastReceivedMessageId, message: message, Message: MessageUIComponent, messageActions: messageActions, readBy: ownMessagesReadByOthers[message.id] || [], sortReactionDetails: sortReactionDetails, sortReactions: sortReactions }),
        showUnreadSeparator && (React.createElement("div", { className: 'str-chat__unread-messages-separator-wrapper' },
            React.createElement(UnreadMessagesSeparator, { unreadCount: unreadMessageCount })))));
};
